[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción al Análisis de Datos con R",
    "section": "",
    "text": "Bienvenidos!\n¡Bienvenidos al curos de Introducción al Análisis de Datos con R!"
  },
  {
    "objectID": "index.html#objetivos-del-curso",
    "href": "index.html#objetivos-del-curso",
    "title": "Introducción al Análisis de Datos con R",
    "section": "Objetivos del curso",
    "text": "Objetivos del curso\n\nReconocer al lenguaje R, y su entorno de desarrollo RStudio, como herramienta para el procesamiento y análisis de datos.\nIdentificar y explicar los tipos y estructuras de datos representados en R.\nIdentificar y emplear funciones y librerías útiles para el procesamiento, visualización y análisis de datos en R.\nAplicar técnicas estadísticas básicas para analizar datos en R.\nCrear visualizaciones efectivas para comunicar resultados.\nAplicar los principios de reproducibilidad para procesar y analizar datos y comunicar resultados"
  },
  {
    "objectID": "index.html#contenidos",
    "href": "index.html#contenidos",
    "title": "Introducción al Análisis de Datos con R",
    "section": "Contenidos",
    "text": "Contenidos\n\nUnidad 1: ¿Qué es R y RStudio? Instalación de R y RStudio. Características RStudio: menús, paneles, etc. Sintaxis de R, convenciones y símbolos de R. Sistema de librerías: instalación y carga. Sistema de ayuda. Tipos de datos: numérico, caracter, lógico. Funciones. Estructuras de datos: vectores, listas, hoja de datos (data frame). El flujo de trabajo en un proyecto de análisis de datos: proyectos, scripts y notebooks. Análisis reproducible.\nUnidad 2: Manipulación de datos con R. Importación y exportación de datos. Librería tidyverse. Gramática de manipulación de datos. Limpieza, normalización, combinación y resumen de datos numéricos y categóricos.\nUnidad 3: Visualizaciones, gráficos. Nociones generales sobre tipos de gráficos y sus usos. Introducción a ggplot2. La gramática de gráficos: estéticas, geometrías, escalas, temas, etc. Gráficos condicionales y multi-paneles.\nUnidad 4: Programación literaria. Generación de informes o reportes con Quarto/RMarkdown.\n\nSin más preámbulos… comencemos!"
  },
  {
    "objectID": "00_introduction.html#la-necesidad-de-analizar-datos",
    "href": "00_introduction.html#la-necesidad-de-analizar-datos",
    "title": "1  Introducción",
    "section": "1.1 La necesidad de analizar datos",
    "text": "1.1 La necesidad de analizar datos\nHoy en día los datos abundan y están en todos lados. Esto desafía nuestra capacidad para analizarlos y extraer significado de los mismos para tomar decisiones.\nLa ciencia de datos (data science) es una nueva disciplina que emerge de la combinación de disciplinas existentes (diagrama) y permite convertir datos sin procesar en entendimiento, comprensión y conocimiento.\n\n\n\n\n\nDiagrama de Venn de la Ciencia de Datos según Conway\n\n\n\n\nPara poder analizar los datos de manera efectiva, es necesario tener conocimientos de disciplinas como ciencias de la computación (programación y más), matemática y estadística. Pero también tenemos que tener conocimientos para lograr el entendimiento del problema en estudio. La combinación de estas áreas nos lleva al concepto de Ciencia de Datos."
  },
  {
    "objectID": "00_introduction.html#cómo-es-el-flujo-de-analisis-de-datos",
    "href": "00_introduction.html#cómo-es-el-flujo-de-analisis-de-datos",
    "title": "1  Introducción",
    "section": "1.2 ¿Cómo es el flujo de analisis de datos?",
    "text": "1.2 ¿Cómo es el flujo de analisis de datos?\nSi bien el análisis de datos es un proceso no lineal que varía en cada situación, existe consenso en cuanto a las principales actividades que se deben desarrollar. El siguiente gráfico resume el flujo de trabajo o workflow.\n\n\n\n\n\nDiagrama de Venn de la Ciencia de Datos según Conway\n\n\n\n\nTodo análisis comienza con importar datos a la herramienta que estemos utilizando, R en este caso. Los datos pueden estar almacenados de diferentes formas, como archivos, dentro de una base de datos o una API ( application programming interface ). En el curso veremos distintas formas de importar datos dentro de R en un formato compatible para su análisis.\nSalvo excepciones, una vez importados los datos, hay que ordenarlos de alguna forma que permita realizar el análisis que queremos. En la mayoría de los casos necesitaremos que los datos estén almacenados de manera rectangular tal que cada columna represente una variable o atributo de los datos y cada fila una o más observaciones o sujetos (formato apaisado).\n\n\n\n\n\nA veces cuando algunas columnas representan valores de una misma variable hay que modificar este formato y pivotar a un formato longitudinal.\nCon los datos ordenados podemos concentrarnos en comprender su estructura y empezar a jugar con ellos. Esta etapa no es para nada lineal y generalmente implica un proceso iterativo donde los datos se visualizan, se transforman y se modelan.\nLa transformación de los datos implica crear subconjuntos o combinar con otros datos, alterar las variables existentes (e.g. cambiar unidades) o generar nuevos atributos combinando información de otros, resumir los datos agrupando observaciones, etc. El manejo de datos de datos ( data wrangling ) es la combinacion de técnicas de ordenamiento y transformación.\nLa visualización es el arte de convertir los datos de forma tabular en gráficos o diagramas donde los disintos atributos de los datos se relacionan a características gráficas tales como ejes, colores, formas, etc. Una buena visualización permitirá revelar patrones inesperados, confirmar alguanas peguntas o sugerir nuevas. Es muy util para comunicar.\nEl modelado es una forma de cuantificar lo podemos ver en una visualización. Al igual que las visualizaciones, los modelos son abstracciones de los datos y nos permiten resumir la variacion quedandonos con la generalidad. Los modelos son ultiles para contestar preguntas sobre los datos. Lo clave es hacer la pregunta correcta! Por otro lado los modelos son tan buenos como los datos de entrada y los supuestos utilizados.\nEl último paso de un proyecto de ciencia de datos es la comunicación. Esta etapa resume todo nuestro trabajo y determina como podemos transmitir nuestras conclusiones y descubrimientos a otros que no participaron del análisis.\nFinalmente, todas y cada una de las etapas de este proceso se desarrollan con la ayuda de la programación. No es necesario ser un hacker, hay que saber pensar como un programador y saber programar ayuda a automatizar tareas."
  },
  {
    "objectID": "00_introduction.html#que-es-un-análisis-reproducible",
    "href": "00_introduction.html#que-es-un-análisis-reproducible",
    "title": "1  Introducción",
    "section": "1.3 ¿Que es un análisis reproducible?",
    "text": "1.3 ¿Que es un análisis reproducible?\nEn las Ciencias Experimentales, poder replicar los experimentos es un componente muy importante del método científico ya que le da validez a los descubrimientos. Es por ello que en los trabajos científicos, una sección importante es la de Materiales y Métodos donde se describen los pasos que se deben dar para poder replicar de los resultados del estudio. Estos pasos incluyen las instrucciones para replicar el experimento físico y de como reproducir el análisis de los datos que llevó a las conclusiones.\nAsí la replicabilidad implica que, siguiendo los materiales y métodos un experimento independiente puede llegar a los mismos resultados con datos distintos. En cambio la reproducibilidad significa que con la misma persona u otra persona con los mismos datos llegue a los mismos resultados, es decir, que pueda reproducir el análisis.\nLa Ciencia de Datos la reproducibilidad computacional es clave ya que en el procesamiento de datos se toman una serie de decisiones que afectan el resultado. ¿Qué significa esto? Dada una serie de datos de entrada, el flujo de trabajo que se aplica para importar, ordenar, transformar, visualizar y modelar los datos, es decir, convertirlos en información, debe estar correctamente documentado para que cualquier persona pueda entender la lógica y eventualemente reproducir los mismos resultados.\nR, como cualquier lenguaje de programación, es una herramienta ideal para aplicar el concepto de reproducibilidad ya que mediante en el código o script quedan plasmados todos los pasos que se aplicaron en el análisis de datos. Más aun, el uso del paradigma de programación literaria permite generar documentos donde se narran todos los pasos y los resultados ontenidos."
  },
  {
    "objectID": "01_install.html#qué-es-r-y-rstudio",
    "href": "01_install.html#qué-es-r-y-rstudio",
    "title": "2  Comenzando con R",
    "section": "2.1 ¿Qué es R y RStudio?",
    "text": "2.1 ¿Qué es R y RStudio?\nR es un lenguaje y entorno para el procesamiento, visualización y análisis estadístico de datos. Fue creado en 1993 por R. Gentleman y R. Ihaka, ambos científicos del Departamento de Estadística de la Universidad de Auckland (Nueva Zelanda). Actualmente su desarrollo y mantenimiento está a cargo del R Core Team (2023). El sitio oficial del proyecto es www.r-project.org.\n\n\n\n\n\nPágina oficial de R Project\n\n\n\n\nHoy en día, R es la lingua franca del procesamiento y análisis de datos, tanto en el ámbito académico como comercial dado que es gratiuto, multiplataforma, de código abierto (open source, liberado con licencia GNU/GPL). Esto y el ecosistema de paquetes contribuidos por la comunidad de usuarios lo convierte en un software muy potente ya que expresa el estado del arte de los métodos estadísticos.\nLa flexibilidad y potencia de R se basa en su interfaz de comandos (CLI, del inglés command line interface ) que permite la ejecución de comandos de manera interactiva (en consola) o estructurada mediante scripts.\n\n\n\n\n\nEjemplo de consola o terminal de Linux y Windows corriendo la última versión estable de R\n\n\n\n\nExisten algunos desarrollos de interfases gráficas (GUIs, del inglés graphical user interface), e.g. RCommander, Deducer, etc., que ofrecen la posibilidad de, mediante menúes y botones dedicados, ejecutar algunos análisis relativamente simples minimizando la necesidad de escribir código.\n\n\n\n\n\nInterfase de R Commander\n\n\n\n\nLos entornos de desarrollo integrados (IDE por sus siglas en inglés integrated development environments) ofrecen un enfoque intermedio: los menúes o funciones asistentes facilitan algunas tareas generales (abrir archivos, carga de datos, exportar gráficos y resultados, etc.) pero dejan la escritura del código y ejecución del análisis estadístico en manos del usuario. Entre estas alternativas se destaca RStudio desarrollado por la empresa posit el cual también es de código abierto (licencia GNU/GPL), multiplataforma y ofrece una versión gratuita.\n\n\n\n\n\nInterfase de RStudio"
  },
  {
    "objectID": "01_install.html#cómo-instalar-r-y-rstudio",
    "href": "01_install.html#cómo-instalar-r-y-rstudio",
    "title": "2  Comenzando con R",
    "section": "2.2 ¿Cómo instalar R y RStudio?",
    "text": "2.2 ¿Cómo instalar R y RStudio?\nR y RStudio se instalan por separado. Ambos softwares son multiplataforma y pueden ser ejecutados en sistemas operativos Windows, Mac OS X y Linux.\nR puede funcionar sin RStudio, en cambio RStudio necesita que al menos una versión de R esté instalada en el sistema.\n\nLa página de descarga de posit https://posit.co/download/rstudio-desktop/ ofrece un excelente punto de partida para instalar ambos programas.\n\n\n\n\n\nPágina de descaga de R\n\n\n\n\nA continuación se describe el procedimiento para instalar R y RStudio bajo Windows.\n\n2.2.1 Instalación de R\n\nClick en el botón DOWNLOAD AND INSTALL R:\n\n\n\n\n\n\nPágina de descaga de R\n\n\n\n\n\n\n\n\n\nPágina de descaga de R\n\n\n\n\n\n\n\n\n\nDirigirse a Install R for firt time\n\n\n\n\n\n\n\n\n\nDirigire a “Download R-X.X.X for Windows”\n\n\n\n\nDescargar el archivo instalador correspondiente a la última versión estable de R desde el CRAN1 (del inglés, Comprenhensive R Archive Network) visitando el siguiente link.\n\nEjecutar el archivo descargado 2 y seguir el asistente de instalación con todas las opciones por defecto.\n\n\nSi la instalación ha sido exitosa en el menú Inicio podrá encontrarse la carpeta R que contendrá dos accesos directos a la interfase de usuario mínima que viene con la versión de R para Windows.\n\n\n\n\n\n\nR GUI para Windows\n\n\n\n\n\n\n2.2.2 Instalación de RStudio\n\nClick en el botón DOWNLOAD RSTUDIO DESKTOP FOR ......:\n\n\n\n\n\n\nPágina de descaga de R\n\n\n\n\nDescargar el archivo de instalación correspondiente a nuestra plataforma o sistema operativo. Al momento de escribir estas instrucciones la última versión estable de RStudio era RStudio-2023.09.0-463.exe que se encuentra en este link\nEn el caso que haya una nueva versión, ir al sitio web de descarga de RStudio https://posit.co/download/rstudio-desktop/\n\n\n\n\n\nPágina de descarga de RStudio\n\n\n\n\n\nEjecutar el archivo .exe y seguir el asistente de instalación con todas las opciones por defecto.\nSi la instalación ha sido exitosa en el menú Inicio dentro de la carpeta RStudio se encontrará el acceso directo a RStudio el cual, mediante el menu contextual (botón derecho del ratón) puede enviarse al Escritorio como acceso directo o bien anclar al menu de Inicio o barra de acceso rápido.\n\n\n\n\n\n\nIcono de RStudio\n\n\n\n\nAhora sí, ya tenemos listo R y RStudio para empezar a trabajar!!\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nInstalar R y RStudio"
  },
  {
    "objectID": "01_install.html#primera-sesión",
    "href": "01_install.html#primera-sesión",
    "title": "2  Comenzando con R",
    "section": "2.3 Primera sesión",
    "text": "2.3 Primera sesión\nEl entorno de trabajo de RStudio se divide en cuatro paneles. La disposición y contenido de los paneles se puede personalizar yendo a View &gt; Panes &gt; Panes Layout.... A continuación la descripción de los paneles principales:\n\n\n\n\n\nInterfase principal de RStudio\n\n\n\n\n\nEditor. Es donde se editan los scripts que son archivos de texto plano con los comandos para ejecutar en R. Este panel no aparece a menos que se cree un nuevo script o se abra uno previamente guardado.\nConsole (consola). Es donde vive R propiamente dicho. Allí se ejecutan los comandos y se obtienen las salidas de R.\nEnvironmnet/History/Connections. En la primera pestaña se visualizan los objetos (variables, funciones o datos cargados) que están disponibles en el entorno de R, i.e. en la memoria. En la segunda se puede ver el historial de comandos ingresados o enviados a la consola. La tercera pestaña visualiza las conexiones establecidas con diferentes base de datos.\nFiles/Plots/Packages/Help/Viewer. Allí se puede manejar los archivos del directorio de trabajo, visualizar los gráficos generados en R con posibilidad de exportarlos en varios formatos, administrar los paquetes o complementos, buscar o explorar el manual de ayuda y previsualizar archivos HTML.\n\n\n2.3.1 La consola\nLa línea de comandos o consola es el modo interactivo mediante el cual podemos ejecutar comandos directamente en el intérprete de R. El símbolo o prompt &gt; indica que R está disponible esperando una orden. Si la orden no está completa el símbolo se transforma en +. Por ejemplo: si tipeamos 2 + 2 y luego ENTER:\n\n2 + 2\n\n[1] 4\n\n\nObetenemos inmediatemente el resultado. Otro ejemplo: el promedio de los números 1, 3 y 4\n\n(1 + 3 + 4) / 3\n\n[1] 2.666667\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nEscribir una operacion matemática, por ejemplo: 3*4\nEscribir algo en la consola. ¿Que sucede?\nEscribir lo anterior entre comillas \" \".\n\n\n\n\n\n2.3.2 El script\nEl editor de scripts (panel #1) es un editor de texto plano que está conectado con la consola (panel #2). Tiene algunas funcionalidades que facilitan la edición del código:\n\nResaltado sintaxis: mediante colores resalta las funciones, variables, comandos o palabras claves del lenguaje R\nSangrado automático: agrega espacios en blanco para mantener la sangría de los bloques de código.\nPlegado de código: permite colapsar bloques de código\nCompletado automático y ayuda en linea: muestra sugerencias para completar el comando o argumentos usando la tecla TAB.\n\nPara crear un nuevo script se puede usar uno de los siguientes métodos:\n\nIr a al menu File &gt; New File &gt; R Script\nUsar el atajo de teclado CTRL + SHIFT + N\nClickear en el primer ícono de la barra de menu\n\n\n\n\n\n\nBarra de herramientas de RStudio\n\n\n\n\nUna vez abierto el script en blanco, se pueden empezar a escribir los comandos de R. Por ejemplo podemos escribir lo siguiente:\n\n\"Hola Mundo!\" # Clásico mensaje \"Hola mundo!\"\n\n# Calcular el promedio de estos números\n(1 + 3 + 4) / 3\n\nEstos comandos no se van a ejecutar automáticamente ya que sólo los hemos escrito en el script. Para ejecutar los comandos en la consola hay que posicionar el cursor en la línea deseada o bien seleccionar si queremos ejecutar varias a la vez y luego enviarlo a la consola con una de las siguientes opciones:\n\nIr al menu Code &gt; Run Selected Line(s)\nUsar el atajo de teclado CTRL + ENTER o CTRL + R\nUsar el ícono Run de la barra de herramientas de la pestaña del script\n\n\n\n\n\n\nBarra de herramientas del panel Editor\n\n\n\n\nEl simbolo # indica que lo que sigue es un comentario y por lo tanto R lo ignora cuando es enviado a la consola. Los comentarios pueden ir solos en una línea separada o bien dentro de una línea que tenga algún comando. Si bien no son necesarios para correr el código, los comentarios son muy útiles para estructurar el script y hacer anotaciones para que otros, o nosotros en un futuro, entiendan lo que hace esa parte del script.\nPara guardar el script:\n\nIr al menu File &gt; Save o usar el atajo de teclado CTRL + S o bien el ícono con el diskette de la barra de herramientas global o de la pestaña del script activo.\nElegir la carpeta destino y el nombre de archivo. Automáticamente se agregará la extensión .R que corresponde a los scripts.\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nAbrir un script nuevo\nEscribir un comentario\nEscribir un texto o un comando numérico\nGuardar el script con el nombre mi_primer_script.R.\n\n\n\n\n\n2.3.3 Directorio de trabajo y proyectos\nR trabaja con un directorio de trabajo o working directory que es la dirección o path que figura en el titulo del panel Console. Esto se puede averiguar con getwd()\n\ngetwd()\n\nPor defecto es el directorio base del usuario que depende de cada plataforma. En linux es el /home/usuario en cambio en Windows es C:/Users/usuario/Documents.\nA menos que se especifique lo contrario, se asume que los archivos de entrada o salida se ubican en esa. Esto se puede modificar en cualquier momento con la función setwd().\n\nsetwd(\"ruta/a/otra/carpeta\")\n\nRStudio extiende esta característica a través de los proyectos o projects. Cada proyecto es una carpeta o folder que contienen un archivo .RProj con algunas configuraciones específicas.\nAl abrir un proyecto, automáticamente se cambia el directorio de trabajo a esta carpeta. Esto permite organizar los archivos de datos, las salidas, los scripts, etc., dentro de un directorio de trabajo (working directory) y volver a ellos de manera más rápida, eficiente, y portable.\nPara crear un proyecto en RStudio:\n\nIr a File &gt; New project... o bien el ícono Create project de la barra de herramientas.\n\n\n\n\n\n\n\nSeleccionar New Directory y en Project type seleccionar New project.\n\n\n\n\n\n\n\n\n\n\nUna vez en el cuadro de diálogo Create new project ingresar el nombre del proyecto (e.g. mi_proyecto) en Directory name que será a su vez el nombre de la carpeta que RStudio va a crear por nosotros.\nLuego en Create project as a subdirectory of indicar donde queremos que RStudio cree la carpeta.\n\n\n\n\n\n\n\nSi todo sale bien, se crea la carpeta con el nombre que indicamos y dentro de ésta un archivo con extensión .Rproj. Este archivo solamente se usa para abrir el directorio. No se debe sobreescribir con el script.\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear un proyecto nuevo con el nombre “Intro_R” en el escritorio o lugar de preferencia.\nCerrar Rstudio.\nAbrir Rstudio desde el proyecto.\nCopiar el script creado en la actividad anterior dentro del nuevo proyecto.\nAbrir el script.\n\n\n\n\n\n2.3.4 Ayuda!!!\nPor último, y no menos importante, R y RStudio cuentan con un completo sistema de ayuda.\nDesde la consola se puede acceder usando la función ? seguida del nombre de la función o bien help(\"nombre\")\n\n# Pedir ayuda de la función mean\n?mean\nhelp(mean)\n\nUna de las ventajas de RStudio es que dispone de un panel (Panel #4) dedicado a visualizar las páginas de ayuda. Allí se puede navegar por las páginas utilizando los links, realizar búsquedas, etc. Leer la documentación nunca viene mal y generalmente ahorra dolores de cabeza.\n\n\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "01_install.html#footnotes",
    "href": "01_install.html#footnotes",
    "title": "2  Comenzando con R",
    "section": "",
    "text": "CRAN es un conjunto de servidores espejo distribuidos alrededor del mundo que tienen copias de R y sus paquetes. No es necesario escojer el espejo más cercano ya que el espejo nube (https://cloud.r-project.org) automáticamente determina de que servidor conviene realizar la descarga.↩︎\nAl momento de escribir estas instrucciones la última versión estable de R era la 4.3.1 Beagle Scouts, por lo tanto el link apuntará al archivo R-4.3.1-win.exe.↩︎"
  },
  {
    "objectID": "02_cloud.html#qué-es-rstudio-cloud",
    "href": "02_cloud.html#qué-es-rstudio-cloud",
    "title": "3  RStudio Cloud",
    "section": "3.1 ¿Qué es RStudio Cloud?",
    "text": "3.1 ¿Qué es RStudio Cloud?\nRStudio Cloud La plataforma RStudio Cloud se define como un Cloud computing. En esta el hardware, software, datos y recursos que utilizabas para tus cursos de estadística pasan de estar en nuestras computadoras a estar “en la nube” https://login.rstudio.cloud/.\nPermite a los usuarios escribir código R, crear visualizaciones y realizar análisis de datos directamente desde su navegador web, sin necesidad de instalar R o RStudio en su computadora local.\n\n\n\n\n\nPágina oficial de RStudio Cloud\n\n\n\n\nVentajas:\n\nAcceso desde cualquier lugar: RStudio Cloud permite a los usuarios acceder a su trabajo desde cualquier computadora con conexión a Internet, lo que facilita la colaboración y el trabajo remoto.\nSin instalación: No es necesario instalar R ni RStudio en el dispositivo local. Esto simplifica el proceso para los principiantes y permite a los usuarios comenzar a trabajar rápidamente sin preocuparse por la configuración del entorno.\nColaboración sencilla: Los proyectos en RStudio Cloud se pueden compartir fácilmente con otros usuarios, lo que facilita la colaboración en tiempo real en proyectos de análisis de datos y ciencia de datos.\nControl de versiones integrado: RStudio Cloud permite a los usuarios vincular sus proyectos con repositorios de control de versiones como GitHub, lo que facilita el seguimiento de los cambios y la colaboración en equipos.\nEntorno preconfigurado: RStudio Cloud viene con paquetes y bibliotecas comunes preinstalados, lo que ahorra tiempo a los usuarios al evitar la necesidad de configurar su entorno de trabajo desde cero.\n\nDesventajas:\n\nLimitaciones de recursos: La versión gratuita de RStudio Cloud puede tener limitaciones en cuanto a la cantidad de recursos computacionales disponibles, lo que puede afectar el rendimiento al realizar análisis de datos intensivos.\nDependencia de la conexión a Internet: RStudio Cloud requiere una conexión a Internet estable para funcionar. Si la conexión es lenta o se pierde, puede dificultar el trabajo continuo.\nLimitaciones de almacenamiento: La cantidad de almacenamiento gratuito en RStudio Cloud puede ser limitada. Los usuarios que trabajan con conjuntos de datos grandes pueden necesitar actualizar a una suscripción de pago para obtener más espacio de almacenamiento."
  },
  {
    "objectID": "02_cloud.html#comenzando-con-rstudio-cloud",
    "href": "02_cloud.html#comenzando-con-rstudio-cloud",
    "title": "3  RStudio Cloud",
    "section": "3.2 Comenzando con RStudio Cloud",
    "text": "3.2 Comenzando con RStudio Cloud\nTendrá que registrarse para obtener una cuenta gratuita para comenzar con RStudio Cloud.\n\n3.2.1 Si ya dispone de una cuenta en RStudio Cloud: Log In\n\n\n\n\n\nLog In en RStudio Cloud\n\n\n\n\n\n\n3.2.2 Si no dispone una cuenta en RStudio Cloud, debe crearla: Sign Up\nHaga clic en el botón Registrarse ( Sign Up )en la esquina superior derecha y aparecerá el siguiente formulario:\n\n\n\n\n\nSign Up en RStudio Cloud\n\n\n\n\nA continuación podrá optar por tres opciones:\n\nPosit Cloud\nshinyapps.io: es una plataforma de servicio (PaaS) para alojar aplicaciones web (apps) Shiny\nPosit User Settings: para editar opciones personales\n\n\n\n\n\n\nSign Up en RStudio Cloud\n\n\n\n\nSeleccionando Posit Cloud, deberá indicar nuevamente el Log In y luego se le presentará el panel de RStudio Cloud:\n\n\n\n\n\nDashboard o Panel de RStudio Cloud"
  },
  {
    "objectID": "02_cloud.html#cómo-crear-un-nuevo-proyecto-en-rstudio-cloud",
    "href": "02_cloud.html#cómo-crear-un-nuevo-proyecto-en-rstudio-cloud",
    "title": "3  RStudio Cloud",
    "section": "3.3 Cómo crear un nuevo proyecto en RStudio Cloud",
    "text": "3.3 Cómo crear un nuevo proyecto en RStudio Cloud\nUna vez en el panel, puede hacer clic en New Project – New RStudio Project para comenzar:\n\n\n\n\n\nNuevo Proyecto en RStudio Cloud\n\n\n\n\nTendrá que esperar entre 30 y 60 segundos hasta que se aprovisione el nuevo proyecto. Una vez hecho esto, verá una interfaz RStudio muy familiar:\n\n\n\n\n\nPanel Nuevo Proyecto en RStudio Cloud\n\n\n\n\n\nPuede renombrar el Proyecto en la esquina superior izquierda, reemplazando Untitled Project.\n\nTodo el IDE en la nube funciona tal como es de esperar. Puede crear un nuevo script R yendo a Archivo – Nuevo archivo – R Script como se muestra a continuación:\n\n\n\n\n\nNuevo Proyecto en RStudio Cloud"
  },
  {
    "objectID": "02_cloud.html#cómo-cargar-y-trabajar-con-datos-en-rstudio-cloud",
    "href": "02_cloud.html#cómo-cargar-y-trabajar-con-datos-en-rstudio-cloud",
    "title": "3  RStudio Cloud",
    "section": "3.4 Cómo cargar y trabajar con datos en RStudio Cloud",
    "text": "3.4 Cómo cargar y trabajar con datos en RStudio Cloud\nPara cargar un conjunto de datos a RStudio Cloud hacer clic en el botón Upload en la pestaña Archivos (cuadrante inferior derecho).\n\n\n\n\n\nCargar archivos en RStudio Cloud\n\n\n\n\nUna vez allí, haga clic en Seleccionar archivo y especifique la ruta a su conjunto de datos:\n\n\n\n\n\nCargar archivos en RStudio Cloud\n\n\n\n\nUna vez que el conjunto de datos se carga en la nube, puede cargarlo en el entorno R. Hay dos enfoques:\n\nBotón Import Dataset: en el cuadrante superior derecho.\nLector de archivos de R: utilice un paquete R dedicado para cargar archivos (ver sección Importar/exportar datos en R datos de este E-book)."
  },
  {
    "objectID": "03_basics.html#operadores-matemáticos-y-lógicos",
    "href": "03_basics.html#operadores-matemáticos-y-lógicos",
    "title": "4  Aspectos básicos de R",
    "section": "4.1 Operadores matemáticos y lógicos",
    "text": "4.1 Operadores matemáticos y lógicos\nComo vimos antes, las operaciones matemáticas básicas se realizan usando los símbolos convencionales:\n\nsuma (+)\nresta (-)\ndivisión (/)\nproducto (*)\npotencia (^)\n\nPor ejemplo, \\(1 + \\left( 3 \\times 4 + \\dfrac{5 -2}{3} \\right)^2\\) en R es:\n\n1 + (3 * 4 + (5 - 2)/3)^2\n\n[1] 170\n\n\nTambién se pueden evaluar expresiones lógicas:\n\nigual que (==)\ndistinto que (!=)\nmayor que (&gt;)\nmenor que (&lt;)\nmayor o igual que (&gt;=)\nmenor o igual que(&lt;=)\n\nEl resultado es TRUE (verdadero) o FALSE (falso). Por ejemplo, podemos evaluar si 3 es igual 4\n\n3 == 4\n\n[1] FALSE\n\n\nO si 5 es mayor o igual a 3\n\n5 &gt;= 3\n\n[1] TRUE\n\n\nTambién se pueden combinar con los operadores intersección (&), unión (|) y negación (!).\nPor ejemplo, evaluar si se cumplen las dos cosas anteriores a la vez\n\n3 == 4 & 5 &gt;= 3\n\n[1] FALSE\n\n\nDevuelve FALSE porque 3 == 4 no es verdadero. Si reemplazamos & por | va a devolver evaluar si una de las dos se cumple:\n\n3 == 4 | 5 &gt;= 3\n\n[1] TRUE\n\n\nTambién se pueden combinar con operaciones matemáticas…\n\n4 * 2 == 8\n\n[1] TRUE\n\n\nEn este caso primero evalúa 4 * 2 y luego compara el resultado con 8\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nHallar el resultado de la siguiente expresión \\((2+4)^2\\) y \\(2^2 + 4^2\\).\nComparar ambos resultados en una linea de comando."
  },
  {
    "objectID": "03_basics.html#variables-y-objetos",
    "href": "03_basics.html#variables-y-objetos",
    "title": "4  Aspectos básicos de R",
    "section": "4.2 Variables y objetos",
    "text": "4.2 Variables y objetos\nUn objeto es un espacio de la memoria que almacena un pedazo de información (una cifra, un conjunto de números, el resultado de un análisis, etc). También se denomina variables ya que su contenido puede cambiar. En R prácticamente todo puede representarse como un objeto.\nLos objetos o variables se crean asignándoles información (números, letras, resultados de operaciones, etc), con el símbolo &lt;- (ALT + -) o =1. Esta informacion se puede recuperar, modificar o utilizar para otros cálculos.\nSupongamos que queremos asignar el valor 2 a la variable x.\n\nx &lt;- 2\n\nEn la consola vuelve a aparecer el simbolo &gt; y nada más. En el ambiente se ve una entrada que dice x y el valor. Podemos recuperar el valor en la consola tipeando el nombre del objeto:\n\nx\n\n[1] 2\n\n\nTambién podemos reusarlo en otro calculo, por ejemplo obtener 2 veces x.\n\n2 * x\n\n[1] 4\n\n\nO bien obtener una nueva variable:\n\ny &lt;- 2 * x +1\ny\n\n[1] 5\n\n\nLos nombres de las variables no deben empezar con números ni contener espacios. No pueden usarse operadores (*+-/&%) en los nombres pero puede usarse . o _.\n\n# Mal\n2x &lt;- 3\nmi variable &lt;- 3\n\n# Bien\nx_2 &lt;- 3\nx.2 &lt;- 3\nx2 &lt;- 3\n\nTambién R es sensibles a mayúsculas\n\n# Definir 'A' y 'a'\nA &lt;- 3\na &lt;- 5\n\n# Verificar si 'A' y 'a' son lo mismo\nA == a\n\n[1] FALSE\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n¿Por qué este código no funciona?\n\nmy_variable &lt;- 10\nmy_varıable\n\n\n\n\n4.2.1 Vectores\nSon los objetos más simples a partir de los cuales se construyen otros tipos de objetos. Se crean utilizando la función c() ( combine ) para “combinar” datos del mismo tipo\n\nx &lt;- c(13, 45, 67, 45)\nx\n\n[1] 13 45 67 45\n\n\nEn el caso de mezclar de datos, R los va a convertir al tipo de datos más simple.\nPor ejemplo: si queremos crear un vector con 3 valores: lógico, numérico y texto, R va a asumir que todos los elementos son de tipo texto\n\ny &lt;- c(TRUE, 34, \"hola\")\ny\n\n[1] \"TRUE\" \"34\"   \"hola\"\n\n\nLos vectores están indexados. Se puede acceder a sus elementos usando el operador [ ] e indicando el número de orden.\nPor ejemplo: para recuperar el 3er elemento del vector x\n\ny[3]\n\n[1] \"hola\"\n\n\nVeremos más adelante los distintos tipos.\n\n\n4.2.2 Funciones y argumentos\nPara crear los vectores sin pensarlo utilizamos una funcion c(). Las funciones son series de comandos que hacen alguna acción y producen un resultado.\nGeneralmente tienen la siguiente la siguiente forma:\nnombre_funcion(arg1, arg2, ...)\ndonde arg son los argumentos (valores de entrada u opciones). Algunos argumentos toman valores por defecto otros hay que declararlos.\nPor ejemplo, la función round()` tiene los argumentos:\n\nx, para pasar el número o vector numérico que queremos redondear\ndigits = 0 para indicar el numero de dígitos a usar, por defecto 0.\n\nSupongamos que queremos redondear el numero 3.141593 a 3 dígitos. Para eso usamos la función round() (buscar en la ayuda ?round)\n\n# Indicando los argumentos\nround(x = 3.141593, digits = 3)\n\n[1] 3.142\n\n# Sin indicar los argumentos\nround(3.141593, 3)\n\n[1] 3.142\n\n\nEn este último caso, el orden de los argumentos es clave ya que R asigna los valores en función de la posición.\n\n# Sin indicar los argumentos\nround(3, 3.141593)\n\n[1] 3\n\n\nDevuelve 3 por considera que queremos redondear el número 3\n\n\n4.2.3 Creando funciones\nAsí como R tiene viene con funciones ya definidias, nosotros podemos crear nuestras propias funciones para poder simplificar nuestro analisis encapsulando tareas repetitivas.\nPor ejemplo, supongamos que queremos calcular el área de 3 rectángulos cuyas dimensiones son:\n\nRectangulo 1: base = 10, altura = 20\nRectangulo 1: base = 15, altura = 35\nRectangulo 1: base = 20, altura = 5\n\nSabemos que la fórumla del área es: \\(A = b \\times a\\), donde \\(A\\) es el area, \\(b\\) es la base y \\(a\\) es la altura.\nPodríamos hacer:\n\n10 * 20\n\n[1] 200\n\n15 * 35 \n\n[1] 525\n\n20 * 5\n\n[1] 100\n\n\nComo vimos antes podemos usar vectores y operar con ellos:\n\nbases &lt;- c(10, 15, 20)\nalturas &lt;- c(20, 35, 5)\nbases * alturas\n\n[1] 200 525 100\n\n\nYendo un poco mas lejos, en vez de repetir siempre la operación podríamos encapsularla en una función. Las funciones se crean con function() o \\() y adentro se declaran los argumentos. Por defecto la función devuelve el ultimo comando o bien lo que se indique en return()\n\narea_rectangulo &lt;- function(base, altura) {\n\n  # Calculo sueperficie\n  area &lt;- base * altura\n\n  return(area)\n\n}\n\nR no devuelve nada porque lo que hizo fue crear la función, a continuación podemos usarla:\n\narea_rectangulo(40,50)\n\n[1] 2000\n\narea_rectangulo(bases, alturas)\n\n[1] 200 525 100\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear una vector llamado diametro que contenga 10 valores numericos\nCalcular otro vector que se llame radios en funcion del anterior\nCrear una función que calcule el area de un círculo. Tip: la constante \\(\\pi\\) en R está en el objeto pi.\nAvanzado: crear una función más avanzada llamada area que calcule el área de un rectángulo o círculo indicando en el argumento figura y suminisitrando el dato de base y altura o radio, según corresponda.\n¿Cómo podríamos expandirla para controlar el número de decimales de la respuesta?"
  },
  {
    "objectID": "03_basics.html#tipos-de-datos",
    "href": "03_basics.html#tipos-de-datos",
    "title": "4  Aspectos básicos de R",
    "section": "4.3 Tipos de datos",
    "text": "4.3 Tipos de datos\n\n4.3.1 Numéricos (numeric)\nNúmeros racionales (enteros o con coma).\n\nx &lt;- c(3, 4, 5)\nclass(x)\n\n[1] \"numeric\"\n\n\nLos números enteros se tratan como numeric a menos que se los convierta con as.integer().\n\ny &lt;- as.integer(x)\nclass(y)\n\n[1] \"integer\"\n\n\nLos datos numéricos permiten todas las operaciones algebráicas\n\nmean(x)\n\n[1] 4\n\nmean(y)\n\n[1] 4\n\n\n\n\n4.3.2 Texto (character)\nCadenas de texto o número delimitadas por comillas (simples o dobles, nom mezclar).\n\nx &lt;- c(\"hola\", '3')\nclass(x)\n\n[1] \"character\"\n\n\nLógicamente no se pueden realizar operaciones numéricas. R avisa y devuelve NA\n\nmean(x)\n\nWarning in mean.default(x): argument is not numeric or logical: returning NA\n\n\n[1] NA\n\n\n\n\n4.3.3 Lógicos (logic)\nCondición verdadero (TRUE o T) o falso (FALSE o F)\n\nlogico &lt;- c(T, F, T, TRUE, FALSE, F)\nlogico\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE FALSE\n\n\nOtro ejemplo: ¿cuáles de los siguientes números son mayores a 30?\n\nx &lt;- c(23, 43, 21, 34, 56, 3, 23, 3)\nx &gt; 30\n\n[1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE\n\n\n\n\n\n4.3.4 Factores (factor y ordered)\nSi los elementos de vector de tipo texto (character) y representan niveles nominales (categorías), el objeto puede convertirse a factor de modo tal que los valores son reemplazados por un número que se asocia a los niveles del factor (ordenados alfabeticamente, a menos que se indique otra cosa).\nUn ejemplo de un vector tipo character.\n\nx &lt;- c('bajo', 'medio', 'alto', 'alto', 'bajo', 'bajo')\nx\n\n[1] \"bajo\"  \"medio\" \"alto\"  \"alto\"  \"bajo\"  \"bajo\" \n\n\nSólo se muestran los valores (bajo, medio y alto). No hay información de niveles. Ahora si aplicamos factor(x):\n\ny &lt;- factor(x)\ny\n\n[1] bajo  medio alto  alto  bajo  bajo \nLevels: alto bajo medio\n\n\nLos valores pasaron al atributo levels y los datos fueron reemplazados por los identificadores 2, 3, y 1 según el orden alfabético de los niveles.\n\nas.numeric(y)\n\n[1] 2 3 1 1 2 2\n\n\nCuando los niveles tienen una jerarquía u orden, se puede especificar este tipo de relación mediante as.ordered() que convierte el factor en uno especial ordered agregando la relación entre los niveles\n\nz &lt;- factor(x, levels = c('bajo', 'medio', 'alto'))\nz &lt;- as.ordered(z)\nz\n\n[1] bajo  medio alto  alto  bajo  bajo \nLevels: bajo &lt; medio &lt; alto\n\n\nLos factores como cualquier vector también se indexan con [ ].\n\n\n4.3.5 Otros tipos de datos\nLos valores faltantes se simbolizan en R con NA (not available). Indican que debería haber un valor pero que está faltando.\n\nx &lt;- c(1, 2, 3, NA, 4)\nis.na(x)\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\n\nA diferencia del NA, un valor de tipo NULL indica que no hay información y que tampoco se esperaba que la haya.\n\nx &lt;- c(1, 2, 3, NULL, 4)\nx\n\n[1] 1 2 3 4\n\n\nAlgunas operaciones matemáticas devuelven valores NaN (not a number) cuando no están definidas, por ejemplo:\n\n0/0\n\n[1] NaN\n\n\nO bien valores infinitos (Inf):\n\n1/0\n\n[1] Inf\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nIngrese lo siguiente en un vector con el nombre color: púrpura, rojo, amarillo, marrón\nMostrar el segundo elemento en el vector (rojo) en la consola.\nIngrese lo siguiente en un vector con el nombre peso: 23, 21, 18, 26"
  },
  {
    "objectID": "03_basics.html#estructura-de-datos",
    "href": "03_basics.html#estructura-de-datos",
    "title": "4  Aspectos básicos de R",
    "section": "4.4 Estructura de datos",
    "text": "4.4 Estructura de datos\nA partir de los tipos de datos que vimos antes, se pueden construir objetos más complejos.\n\n4.4.1 Matriz (matrix)\nColección de vectores de igual longitud y mismo tipo de datos. Se crea con la función matrix(), o combinando filas o columnas de igual longitud con rbind() o cbind().\nPor ejemplo la matriz:\n\\[\n\\mathbf{M} = \\left[\\begin{array}{c c}\n1 & 2 \\\\\n3 & 4 \\\\\n5 & 6 \\\\\n\\end{array} \\right]\n\\] en R se representa así:\n\nM &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2)\nM\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n\nSe puede indexar usando [n, p] donde n es el numero de fila y p numero de columna. Por ejemplo para obtener el elemento \\(m_{12}\\)\n\nM[1,2]\n\n[1] 4\n\n\nO todos los elementos de la columna 2\n\nM[, 2]\n\n[1] 4 5 6\n\n\n\n\n4.4.2 Listas (list)\nEs una generalización de los vectores ya que los elementos pueden ser de igual o diferente tipo de datos\n\nlst &lt;- list(23, \"hola\", TRUE)\nlst\n\n[[1]]\n[1] 23\n\n[[2]]\n[1] \"hola\"\n\n[[3]]\n[1] TRUE\n\n\nSe pueden indexar usando [[ ]]\n\n# El segundo elemento de l\nlst[[2]]\n\n[1] \"hola\"\n\n\nCada elemento a su vez puede ser cualquier objeto de los vistos anteriormente.\n\n\n4.4.3 Hoja de datos (data.frame)\nSimilares a las matrices pero cada columna puede ser de un tipo de dato diferente. Útil para guardar datos donde cada fila es un caso y cada columna una variable.\nSupongamos que tenemos la tabla de datos:\n\n\n\nLote\nVariedad\nRendimiento\n\n\n\n\n1\nEscorpion\n34\n\n\n2\nEscorpion\n36\n\n\n3\nYarara\n40\n\n\n4\nBaguette11\n28\n\n\n5\nTijetera\n31\n\n\n\nEn R podemos representarla así:\n\ntrigo &lt;- data.frame(\n  lote = 1:5,\n  variedad = c('Escorpion', 'Escorpion', 'Yarara', 'Baguette 11', 'Tijetera'),\n  rendimiento = c(34, 36, 40, 28, 31)\n)\ntrigo\n\n  lote    variedad rendimiento\n1    1   Escorpion          34\n2    2   Escorpion          36\n3    3      Yarara          40\n4    4 Baguette 11          28\n5    5    Tijetera          31\n\n\nAl igual que las matrices, un data.frame se puede indexar con [ ]. Por ejemplo, si quisieramos El bombre de la varidedad de la fila 2\n\ntrigo[2, 3]\n\n[1] 36\n\n\nO todos los nombres de la fila 2\n\ntrigo[2, ]\n\n  lote  variedad rendimiento\n2    2 Escorpion          36\n\n\nTambien podemos hacer consultas más específicas: “Lotes con rendimiento mayor a 35 qq/ha”\n\ntrigo[trigo$rendimiento &gt; 35, ]\n\n  lote  variedad rendimiento\n2    2 Escorpion          36\n3    3    Yarara          40\n\n\nLas variables o columnas se pueden acceder individualmente usando o el operador $ seguido dle nombre de la columna o [, \"nombre\"], o [, posicion]. Ejemplo: extraer la columna rendimiento que es la número 3\n\ntrigo$rendimiento\n\n[1] 34 36 40 28 31\n\ntrigo[, \"rendimiento\"]\n\n[1] 34 36 40 28 31\n\ntrigo[, 3]\n\n[1] 34 36 40 28 31\n\n\n\n\n\n\n\n\nOtras estructuras\n\n\n\nLas estructura listadas arriba son nativas de R. Los paquetes o complementos pueden agregar nuevas estructuras o redifinar las existentes.\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nUnir los 2 vectores de la actividad anterior usando la función data.frame para crear un marco de datos llamado info con 2 columnas y 4 filas. Llame a la primera columna ’color y a la segunda peso.\nVer la estructura de datos en la consola.\nMostrar solo la fila 3 en la consola\nMostrar solo la columna 1 en la consola\nMostrar el elemento de datos en la fila 4, columna 1"
  },
  {
    "objectID": "03_basics.html#footnotes",
    "href": "03_basics.html#footnotes",
    "title": "4  Aspectos básicos de R",
    "section": "",
    "text": "Si bien &lt;- funciona igual que = en la mayoría de los casos, por convención se usa &lt;- para asignar y = para argumentos dentro de las funciones.↩︎"
  },
  {
    "objectID": "04_paquetes.html#qué-son-los-paquetes",
    "href": "04_paquetes.html#qué-son-los-paquetes",
    "title": "5  Paquetes de R",
    "section": "5.1 ¿Qué son los paquetes?",
    "text": "5.1 ¿Qué son los paquetes?\nR viene con un conjunto de librerías mínimo denominado core que permite realizar una amplia varidedad de análisis y operaciones con los datos. La comunidad que desarrolla R provee un repositorio de librerías o paquetes complementarios (packages) que expanden notablemente las funcionalidades de R.\nLos paquetes se deben instalar primero usando la función install.packages() por única vez y en cada sesión se deben cargar con library(). La siguiente figura resume el proceso:\n\n\n\n\n\nSuponiendo que queremos instalar el paquete foo, se debe ejecutar por única vez:\n\ninstall.packages(\"foo\")\n\nLuego, para acceder a todas las funciones que aporta foo, en cada sesión de trabajo ejecutar hay que ejecutar:\n\nlibrary(\"foo\")\n\nAlternativamente, si una vez instalado el paquete foo queremos usar la función bar() pero sin cargar el resto del paquete, entonces:\n\nfoo::bar(...)\n\nEl manejo de paquetes se puede simplificar enormemente con el paquete pacman. Entre otras funciones ofrece la función p_load() que carga los paquetes y si no están instalados los instala previamente.\nPara instalar pacman por primera vez correr el siguiente comando:\n\n# Instalar por unica vez\ninstall.packages(\"pacman\")\n\nLuego, cuando necesitemos podemos ejecutar pacman::p_load(). Por ejemplo, si queremos cargar el paquete moments\n\npacman::p_load(moments)\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nInstalar el paquete pacman usando install.packages()\nCargar/Instalar el paquete tidyverse usando pacman::p_load()"
  },
  {
    "objectID": "05_import.html#importar-datos",
    "href": "05_import.html#importar-datos",
    "title": "6  Importar/exportar datos en R",
    "section": "6.1 Importar datos",
    "text": "6.1 Importar datos\n\n6.1.1 Funciones nativas\nR viene la función read.table() y derivados, que permiten leer datos desde formatos tipo texto plano (plain text format). El más popular entre estos es *.csv. Este formato asume que los datos están en formato de tabla o rectangular (e.g. variables en columnas y observaciones en filas) y devuelve un data.frame. En ?read.table se detallan todos los argumentos, los más importantes son:\n\nfile para indicar el nombre o ruta al archivo\nheader para indicar si las columnas tienene encabezados que deben ser usados como nombre de las variables.\nsep para indicar el separador de columnas\ndec para indicar el simbolo decimal\n\nDependiendo de las combinaciones de estos 3 argumentos hay variantes (read.csv(), read.csv2(), read.delim(), read.delim2()) que son atajos de `read.table()`` (ver ayuda).\nMediante algun editor de textos (puede ser dentro de RStudio) conviene abrir el archivo y examinarlo para determinar:\n\nTiene encabezados?\nCómo están separadas las columnas?\nCuál es el símbolo del decimal?\n\nSupongamos que tenemos el archivo de texto prueba.csv, las alternativas podrían ser:\n\n# Con encabezados, separado por tabulaciones y el decimal es el punto\nprueba &lt;- read.table(\"prueba.csv\", header = T, sep = \"\\t\", dec = \".\")\n\n# Con encabezados, separado por tabulaciones y coma como decimal\nprueba &lt;- read.table(\"prueba.csv\", header = T, sep = \"\\t\", dec = \",\")\n\n# Con encabezados, separado comas y punto como decimal\nprueba &lt;- read.table(\"prueba.csv\", header = T, sep = \",\", dec = \".\")\n\n# Con encabezados, separado punto y coma, y con coma como punto decimal\nprueba &lt;- read.table(\"prueba.csv\", header = T, sep = \";\", dec = \",\")\n\nEn el caso que el archivo prueba.csv esté en otro directorio o ubicación que no sea el proyecto o getwd() hay que indicar la ruta completa al archivo.\nUna vez importados los datos es conveniente verificar como han sido leidos en el R. Una alternativa es imprimirlo escribiendo el nombre del objeto directamente en la consola.\n\nprueba\n\nOtra alternativa es utilizar la función View() que muestra la tabla de datos en un formato de planilla interactiva de solo lectura.\n\nView(prueba)\n\nSi bien podemos inferir que tipo de datos se leyeron, una alternativa mejor es mirar la estructura con la función str().\n\nstr(prueba)\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nAbrir un documento de texto en RStudio\nRetomando el ejemplo del set de datos de trigo, crear un archivo separado por comas con los siguientes datos\n\nLote,Variedad,Rendimiento\n1,Escorpion,34\n2,Escorpion,36\n3,Yarara,40\n4,Baguette11,28\n5,Tijetera,31\n\nGuardar el archivo como prueba_trigo.csv.\nLeer el set de datos dentro de R usando la función read.table() o alguna de sus variantes.\nVerificar la importacion de los datos.\n\n\n\n\n\n6.1.2 Paquetes para importar/exportar datos\nExisten paquetes específicos que permiten leer virtualmente cualquier formato de archivos.\n\n6.1.2.1 readr\nSi bien la función read.table() y derivadas permiten leer datos rectangulares en formato texto, el paquete readr link provee una implementación más moderna (y rápidas) de estas funciones. Las funciones se llaman igual que las nativas pero se reemplaza . por _ en el nombre. Ejemplo: read_table()\nEste paquete ya está integrado a tidyverse. Para leer el set de datos que creamos en la actividad anterior:\n\npacman::p_load(tidyverse)\nprueba_trigo &lt;- read_csv(\"datasets/prueba_trigo.csv\")\n\nRows: 5 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Variedad\ndbl (2): Lote, Rendimiento\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nprueba_trigo\n\n# A tibble: 5 × 3\n   Lote Variedad   Rendimiento\n  &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt;\n1     1 Escorpion           34\n2     2 Escorpion           36\n3     3 Yarara              40\n4     4 Baguette11          28\n5     5 Tijetera            31\n\n\nA diferencia de la función nativa, las funciones de readr devuelven un objeto llamado tibble que es una especie de data.frame pero con algunas propiedades extra.\n\n\n6.1.2.2 rio\nA diferencia de readr que es una reimplementación de funciones de R, hay un paquete llamado rio link que es una especie de metapaquete y permite simplificar la importación, exportación, y conversión de formatos en una sintaxis unificada.\nEste paquete trabaja con una mayor variedad de formatos y, basado en la extensión del archivo, busca la función y/o paquete apropiado para leer o guardar los datos. En el caso de ser necesario, se pueden pasar argumentos a las funciones.\nRetomando el ejemplo de trigo, podemos leer los datos con la función import()\n\npacman::p_load(rio)\nprueba_trigo &lt;- import(\"datasets/prueba_trigo.csv\")\nprueba_trigo\n\n  Lote   Variedad Rendimiento\n1    1  Escorpion          34\n2    2  Escorpion          36\n3    3     Yarara          40\n4    4 Baguette11          28\n5    5   Tijetera          31\n\n\nA diferencia de readr siempre devuelve un data.frame. Si queremos que devuelva un tibble podemos usar el argumento setclass\n\nprueba_trigo &lt;- import(\"datasets/prueba_trigo.csv\", setclass = \"tibble\")\nprueba_trigo\n\n# A tibble: 5 × 3\n   Lote Variedad   Rendimiento\n  &lt;int&gt; &lt;chr&gt;            &lt;int&gt;\n1     1 Escorpion           34\n2     2 Escorpion           36\n3     3 Yarara              40\n4     4 Baguette11          28\n5     5 Tijetera            31\n\n\n\n\n\n6.1.3 Formas de importar datos\nA continuación vamos a detallar dos formas de abrir el archivo urbana_weather.xlsx que contiene datos meteorológicos de la ciudad de Urbana (Illinois).\n\n6.1.3.1 Desde la consola (recomendado)\nUna vez que descargamos el archivo datos en la carpeta datasets dentro de nuestro directorio de trabajo o proyecto podemos leerlo en R usando la función import() del paquete rio. Esta función se encargará de llamar la función necesaria para leer el archivo que le suministremos.\n\nurbana &lt;- import(\"datasets/urbana_weather.xlsx\", setclass = \"tibble\")\nurbana\n\n# A tibble: 240 × 4\n    YEAR month precip  temp\n   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n 1  2000 Jan     1.54  25.6\n 2  2001 Jan     1.32  25.4\n 3  2002 Jan     2.81  34  \n 4  2003 Jan     0.79  21.1\n 5  2004 Jan     2.18  24  \n 6  2005 Jan     6.2   27.8\n 7  2006 Jan     1.78  37.8\n 8  2007 Jan     3.03  29.7\n 9  2008 Jan     2.31  26.2\n10  2009 Jan     0.68  18.8\n# ℹ 230 more rows\n\n\nSi sólo estuvieramos ineresados en el rango A1:C5 (primeros 4 registros de las 3 primeras columnas), podríamos usar:\n\nurbana2 &lt;- import(file = \"datasets/urbana_weather.xlsx\", range = \"A1:C5\")\nurbana2\n\n  YEAR month precip\n1 2000   Jan   1.54\n2 2001   Jan   1.32\n3 2002   Jan   2.81\n4 2003   Jan   0.79\n\n\n\n\n6.1.3.2 Desde el importador de datos de RStudio\nRStudio cuenta con un asistente de importación de datos (File &gt; Import Dataset) que brinda interfase a varias funciones especializadas en la importación de datos de paquetes específicos como readr, readxl, etc.\nEn el menú File &gt; Import Dataset o bien el ícono del panel Environment despliega una lista con disitintas opciones de importación: nos interesa From Excel (readxl)...\n\n\n\n\n\nImportador de datos\n\n\n\n\n\n\n\n\n\nImportador de datos\n\n\n\n\nEste menú tiene cuatro paneles:\n\nUna barra de direccion para indicar la ruta al archivo o URL.\nUna vista previa del contenido del archivo\nOpciones de importación: aquí se puede especificar el nombre del objeto que se creará dentro de R (Name), la cantidad de lineas a leer, el número de la hoja, el rango de celdas, líneas a saltear (skip) y el identificador de datos NA.\nVista previa del código. En esta parte se puede visualizar como se construye el comando que se ejecturará al clickear en Import.\n\n\n\n\n\n\n\nAclaración\n\n\n\nSi bien esta alternativa es intuitiva y amigable, no es reproducible a menos que el código generado por este asistente sea incluido en el script para futuras sesiones.\n\n\n\n\n6.1.3.3 Desde el portapapeles\nUna alternativa conveniente para acceder rápidamente a los datos es usando el portapapeles. Suponiendo que los datos estan en una hoja de cálculos:\n\nSeleccionar el rango de celdas A1:C5 que nos interesa incluyendo los encabezados\nCopiar en el porta papeles (CTRL + C)\nLuego en R\n\n\nurbana3 &lt;- read.table(\"clipboard\")\n\n\n\n\n\n\n\nAclaración\n\n\n\nSi bien esta alternativa es rápida, al no ser reproducible (no hay forma de plasmarla en el script para futuras sesiones), no es recomendable salvo para una exploración rápida."
  },
  {
    "objectID": "05_import.html#exportar-datos",
    "href": "05_import.html#exportar-datos",
    "title": "6  Importar/exportar datos en R",
    "section": "6.2 Exportar datos",
    "text": "6.2 Exportar datos\nAsí como R viene con la función read.table() y derivados, que permiten leer datos desde formatos tipo texto plano (plain text format). Existen funciones que hacen lo contrario: exportar data.frames a archivos de texto plano. Estas funciones se comienzan con el nombre write* (write.table(), write.csv(), …).\nAl igual que read.table() tiene argumentos claves para espeficiar:\n\nfile para indicar el nombre o ruta al archivo\nheader para indicar si las columnas tienene encabezados que deben ser usados como nombre de las variables.\nsep para indicar el separador de columnas\ndec para indicar el simbolo decimal\n\nAdemás se le agrega el argumento x para especificar que objeto (data.frame) queremos exportar.\nSupongamos que tenemos el set de datos prueba en R y queremos exportarlo a CSV con titulos separados por ; y punto decimal.\n\nwrite.table(prueba, file = \"prueba.csv\", header = T, sep = \";\", dec = \",\")\n\nEn el archivo prueba.csv se escribira en el directorio de trabajo (getwd())\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nExportar el objeto creado en la actividad anterior con datos de rendimiento de trigo a un archivo CSV llamado prueba_trigo2.csv.\nVerificar como se exportó.\n\n\n\n\n6.2.1 readr\nDe la misma manera que las funciones nativas, el paquete readr provee funciones contrarias a read_table() y derivadas.\n\npacman::p_load(tidyverse)\nwrite_csv(x = prueba, file = \"prueba.csv\")\n\nError in eval(expr, envir, enclos): object 'prueba' not found\n\n\nA diferencia de la función nativa, tienen algunas opciones extra.\n\n\n6.2.2 rio\nEste metapaquete y permite simplificar la exportación de formatos en una sintaxis unificada con la función export().\nRetomando el ejemplo de trigo, podemos exportar los datos con la función export(). Suponiendo que el data.frame se llama trigo.\n\npacman::p_load(rio)\nexport(x = trigo, file = \"prueba_trigo.csv\")\n\nError in eval(expr, envir, enclos): object 'trigo' not found\n\n\nEl formato de salida podemos indicarlo con la extensión apropiada.\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nExportar el objeto de la actividad anterior a un formato Excel.\nVerificar como se exportó."
  },
  {
    "objectID": "06_wrangling.html#estrategia-split-apply-combine",
    "href": "06_wrangling.html#estrategia-split-apply-combine",
    "title": "7  Manipulando datos",
    "section": "7.1 Estrategia split-apply-combine",
    "text": "7.1 Estrategia split-apply-combine\nEn la manipulación de datos frecuentemente se usa la estrategia split-apply-combine, es decir:\n\ndividir ( split ) los datos según una variable de grupo\naplicar ( apply ) alguna transformación o resumen\ncombinar ( combine ) las partes para presentar los resultados\n\nR base tiene funciones que realizan estas tareas (split(), subset(), apply(), sapply(), lapply(), tapply() and aggregate()), pero orientadas a trabajar con vectores.\ndplyr y tidyr son dos paquetes de R muy potentes para la exploración, transformación y resumen de datos en formato de tabla con filas (observaciones) y columnas (variables). Ambos son componentes de un meta-package tidyverse desarrollados por Hadley Wickham\nAmbos paquetes tienen un conjunto de funciones (o verbos) que realizan operaciones comunes para el manejo de datos (filtrar filas, seleccionar columnas, re-ordenar filas, agregar o transformar columnas, resumir), mediante una interface más consistente orientada a datos rectangulares (data.frame) aplicando esta estrategia de dividir, aplicar y combinar."
  },
  {
    "objectID": "06_wrangling.html#cómo-instalar-dplyr-y-tidyr",
    "href": "06_wrangling.html#cómo-instalar-dplyr-y-tidyr",
    "title": "7  Manipulando datos",
    "section": "7.2 ¿Cómo instalar dplyr y tidyr?",
    "text": "7.2 ¿Cómo instalar dplyr y tidyr?\nPara acceder a estos paquetes podemos hacerlo a través del meta-paquete tidyverse\n\npacman::p_load(tidyverse)\n\nR va a avisarnos en la consola que esta enmascarando (reemplazando) algunas funciones que ya estaban en el entorno, o bien el paquete nos devuelve algun mensaje. A menos que diga Error ..., eso está bien.\nAlternativamente podemos instalarlos/cargarlos individualmente:\n\npacman::p_load(dplyr, tidyr)"
  },
  {
    "objectID": "06_wrangling.html#verbos-importantes-de-dplyr-para-recordar",
    "href": "06_wrangling.html#verbos-importantes-de-dplyr-para-recordar",
    "title": "7  Manipulando datos",
    "section": "7.3 Verbos importantes de dplyr para recordar",
    "text": "7.3 Verbos importantes de dplyr para recordar\nToda la estrategia de trabajo con datos de dplyr se basa en 6 verbos generales:\n\n\n\nverbo\ndescripción\n\n\n\n\nselect()\nselecciona columnas (variables)\n\n\nfilter()\nfiltra o selecciona las filas (observaciones)\n\n\narrange()\nre-ordena las filas\n\n\nmutate()\ncrea nuevas columnas o modifica las preexistentes\n\n\nsummarise()\nresumen los valores de una variable\n\n\ngroup_by()\npermite aplicar los verbos anteriores en subgrupos\n\n\n\nEl último verbo group_by() es clave para split-apply-combine.\nAdemás de estos verbos hay otros más específicos que vamos a ir viendo con ejemplos.\nEn la mayoría de los casos la sintaxis es:\nverbo(que_datos, que_hacer_con_los_datos)\ndonde verbo() es uno de los verbos listados arriba, que_datos es el nombre del set de datos (un data.frame) y que_hacer_con_los_datos indicar que operación, condicion, transformacion, etc. aplicar a las filas y columnas."
  },
  {
    "objectID": "06_wrangling.html#seleccionando-variables",
    "href": "06_wrangling.html#seleccionando-variables",
    "title": "7  Manipulando datos",
    "section": "7.4 Seleccionando variables",
    "text": "7.4 Seleccionando variables\nPara seleccionar columnas (variables) de interés usamos select(). La selección se puede hacer por nombre de la columna (con o sin comillas) o indicando su posición o un rango.\nLas columnas del set de datos de ejemplo se denominan:\n\nnames(novillos)\n\n [1] \"IDV\"           \"Tropa\"         \"Procedencia\"   \"Fecha_Ingreso\"\n [5] \"Peso_inicial\"  \"Peso_anterior\" \"GPV_anterior\"  \"GDM_anterior\" \n [9] \"Fecha\"         \"Hora\"          \"Peso\"          \"Días\"         \n[13] \"Días_total\"   \n\n\nSi quisieramos seleccionar las columnas Procedencia, Peso_inicial, Peso_anterior y Peso, podríamos ejectuar:\n\nselect(novillos, Procedencia, Peso_inicial, Peso_anterior, Peso)\n\n# A tibble: 1,842 × 4\n   Procedencia    Peso_inicial Peso_anterior  Peso\n   &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;\n 1 &lt;NA&gt;                    188           306   398\n 2 La Rosita               232           290   387\n 3 La Alameda              204           290   386\n 4 &lt;NA&gt;                    204           303   382\n 5 La Alameda              202           300   382\n 6 La Rosita               234           333   374\n 7 Los Corralitos          214           287   371\n 8 Los Corralitos          184           315   369\n 9 La Rosita               234           288   365\n10 La Alameda              206           262   365\n# ℹ 1,832 more rows\n\n\nEl resultado es un nuevo data.frame o tibble que sólo contiene las 4 columnas seleccionadas. Si quisieramos guardar este resultado aparte podemos asignarlo a un objeto.\n\npesos &lt;- select(novillos, Procedencia, Peso_inicial, Peso_anterior, Peso)\npesos\n\n# A tibble: 1,842 × 4\n   Procedencia    Peso_inicial Peso_anterior  Peso\n   &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;\n 1 &lt;NA&gt;                    188           306   398\n 2 La Rosita               232           290   387\n 3 La Alameda              204           290   386\n 4 &lt;NA&gt;                    204           303   382\n 5 La Alameda              202           300   382\n 6 La Rosita               234           333   374\n 7 Los Corralitos          214           287   371\n 8 Los Corralitos          184           315   369\n 9 La Rosita               234           288   365\n10 La Alameda              206           262   365\n# ℹ 1,832 more rows\n\n\nCuando se imprime en la consola, es lo mismo que usar print() la cual por defecto muestra las 10 primeras observaciones y la cantidad de columnas que entran en la pantalla. Aquellas columnas que no entran son indicadas al pie.\nSi uno desea ver más registros se puede usar el argumento n = de print()\n\nprint(pesos, n = 15)\n\n# A tibble: 1,842 × 4\n   Procedencia    Peso_inicial Peso_anterior  Peso\n   &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;\n 1 &lt;NA&gt;                    188           306   398\n 2 La Rosita               232           290   387\n 3 La Alameda              204           290   386\n 4 &lt;NA&gt;                    204           303   382\n 5 La Alameda              202           300   382\n 6 La Rosita               234           333   374\n 7 Los Corralitos          214           287   371\n 8 Los Corralitos          184           315   369\n 9 La Rosita               234           288   365\n10 La Alameda              206           262   365\n11 La Alameda              216           308   362\n12 La Rosita               240           298   362\n13 La Alameda              164           285   361\n14 La Rosita               216           308   361\n15 La Alameda              176           289   361\n# ℹ 1,827 more rows\n\n\nCon n = \"all\" o n = Inf se imprimen todas (no se muestra por razones obvias)\nEl orden en que aparecen las variables en el resultado es el orden que se utilizó al seleccionarlas.\n\nselect(novillos, Procedencia, Peso, Peso_inicial, Peso_anterior)\n\n# A tibble: 1,842 × 4\n   Procedencia     Peso Peso_inicial Peso_anterior\n   &lt;chr&gt;          &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;\n 1 &lt;NA&gt;             398          188           306\n 2 La Rosita        387          232           290\n 3 La Alameda       386          204           290\n 4 &lt;NA&gt;             382          204           303\n 5 La Alameda       382          202           300\n 6 La Rosita        374          234           333\n 7 Los Corralitos   371          214           287\n 8 Los Corralitos   369          184           315\n 9 La Rosita        365          234           288\n10 La Alameda       365          206           262\n# ℹ 1,832 more rows\n\n\nTambién se puede usar los comandos starts_with(), ends_with(), contains(), etc (ver ?select_helpers) para más opciones). Para elegir varias columnas que tienen un patrón sin tener que tipear todos los nombres.\n\nselect(novillos, starts_with(\"P\"))\n\n# A tibble: 1,842 × 4\n   Procedencia    Peso_inicial Peso_anterior  Peso\n   &lt;chr&gt;                 &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;\n 1 &lt;NA&gt;                    188           306   398\n 2 La Rosita               232           290   387\n 3 La Alameda              204           290   386\n 4 &lt;NA&gt;                    204           303   382\n 5 La Alameda              202           300   382\n 6 La Rosita               234           333   374\n 7 Los Corralitos          214           287   371\n 8 Los Corralitos          184           315   369\n 9 La Rosita               234           288   365\n10 La Alameda              206           262   365\n# ℹ 1,832 more rows\n\n\nO según el tipo de varabiles con where(). Por ejemplo, aquellas que son de tipo numeric.\n\nselect(novillos, where(is.numeric))\n\n# A tibble: 1,842 × 8\n   Tropa Peso_inicial Peso_anterior GPV_anterior GDM_anterior  Peso  Días\n   &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1     2          188           306           51         1.04   398    76\n 2     2          232           290            2         0.04   387    76\n 3     2          204           290           33         0.67   386    76\n 4     2          204           303           27         0.52   382    75\n 5     2          202           300           30         0.58   382    75\n 6     2          234           333           38         0.73   374    75\n 7     2          214           287           14         0.27   371    75\n 8     2          184           315           37         0.76   369    76\n 9     2          234           288            0         0      365    76\n10     2          206           262            2         0.08   365   132\n# ℹ 1,832 more rows\n# ℹ 1 more variable: Días_total &lt;dbl&gt;\n\n\nTambien podemos seleccionar por rangos de nombres o posicion. Por ejemplo las primeras 4 columnas:\n\nselect(novillos, 1:4)\n\n# A tibble: 1,842 × 4\n   IDV       Tropa Procedencia    Fecha_Ingreso\n   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;        \n 1 GH738B371     2 &lt;NA&gt;           42939        \n 2 IA671B298     2 La Rosita      42940        \n 3 PO150A818     2 La Alameda     42939        \n 4 GH738B340     2 &lt;NA&gt;           42940        \n 5 SZ208H766     2 La Alameda     42940        \n 6 IA671B133     2 La Rosita      42940        \n 7 PO150A532     2 Los Corralitos 42938        \n 8 PO150A563     2 Los Corralitos 42939        \n 9 NS509H071     2 La Rosita      42938        \n10 QX678K546     2 La Alameda     42940        \n# ℹ 1,832 more rows\n\n\nLo mismo pero usando un rango de nombres:\n\nselect(novillos, IDV:Fecha_Ingreso)\n\n# A tibble: 1,842 × 4\n   IDV       Tropa Procedencia    Fecha_Ingreso\n   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;        \n 1 GH738B371     2 &lt;NA&gt;           42939        \n 2 IA671B298     2 La Rosita      42940        \n 3 PO150A818     2 La Alameda     42939        \n 4 GH738B340     2 &lt;NA&gt;           42940        \n 5 SZ208H766     2 La Alameda     42940        \n 6 IA671B133     2 La Rosita      42940        \n 7 PO150A532     2 Los Corralitos 42938        \n 8 PO150A563     2 Los Corralitos 42939        \n 9 NS509H071     2 La Rosita      42938        \n10 QX678K546     2 La Alameda     42940        \n# ℹ 1,832 more rows\n\n\nPara omitir algunas columnas en la seleccion se puede usar el - antes del nombre. Por ejemplo, omitir la columna IDV y todas las que empiezan con P.\n\nselect(novillos, -IDV, -starts_with(\"P\"))\n\n# A tibble: 1,842 × 8\n   Tropa Fecha_Ingreso GPV_anterior GDM_anterior Fecha Hora      Días Días_total\n   &lt;dbl&gt; &lt;chr&gt;                &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1     2 42939                   51         1.04 43138 0.80824…    76        293\n 2     2 42940                    2         0.04 43138 0.46511…    76        293\n 3     2 42939                   33         0.67 43138 0.34270…    76        302\n 4     2 42940                   27         0.52 43138 0.34829…    75        293\n 5     2 42940                   30         0.58 43138 0.80134…    75        304\n 6     2 42940                   38         0.73 43138 0.34018…    75        295\n 7     2 42938                   14         0.27 43138 0.32917…    75        303\n 8     2 42939                   37         0.76 43138 0.33152…    76        303\n 9     2 42938                    0         0    43138 0.37302…    76        302\n10     2 42940                    2         0.08 43143 0.46458…   132        306\n# ℹ 1,832 more rows\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nSeleccionar las colunas que son character y aquellas cuyo nombre contiene la palabra “Peso” o termina con “anterior”. Guardar el resultado en un objeto.\nActualizar el objeto del punto anterior descartar las columnas “Fecha_Ingreso”, “Fecha”, “Hora”.\nUsando rio::export() exportar el set de datos a un archivo excel.\nVerificar el archivo exportado."
  },
  {
    "objectID": "06_wrangling.html#seleccionando-observaciones",
    "href": "06_wrangling.html#seleccionando-observaciones",
    "title": "7  Manipulando datos",
    "section": "7.5 Seleccionando observaciones",
    "text": "7.5 Seleccionando observaciones\nOtra tarea muy frecuente es seleccionar casos o observaciones que cumplan con alguna condición. Esto se lleva a cabo con filter().\nSe pueden usar los operadores lógicos (==, &gt;, &lt;, &gt;=, &lt;=, !=) o booleanos (&, |) para crear pruebas o condiciones lógicas.\nUn operador que no vimos antes es el pertenece %in% el que se usa para chequear si un valor está dentro de un conjunto de valores posibles. Por ejemplo para chequar si el número 2 está dentro un conjunto de numeros del 1 al 10.\n\n2 %in% 1:10\n\n[1] TRUE\n\n\nPor ejemplo, para seleccionar los novillos de Los Corralitos:\n\nfilter(novillos, Procedencia == 'Los Corralitos')\n\n# A tibble: 57 × 13\n   IDV   Tropa Procedencia Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 PO15…     2 Los Corral… 42938                  214           287           14\n 2 PO15…     2 Los Corral… 42939                  184           315           37\n 3 PO15…     2 Los Corral… 42937                  168           266           22\n 4 PO15…     2 Los Corral… 42937                  182           281           31\n 5 PO15…     2 Los Corral… 42938                  200           276           20\n 6 PO15…     2 Los Corral… 42937                  162           231           19\n 7 PO15…     2 Los Corral… 42937                  166           240           26\n 8 PO15…     2 Los Corral… 42942                  162           232           28\n 9 PO15…     2 Los Corral… 42939                  200           258           26\n10 PO15…     2 Los Corral… 42940                  170           252           37\n# ℹ 47 more rows\n# ℹ 6 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;\n\n\nPara crear un subconjunto podemos asignarlo y crear un nuevo set de datos.\n\ncorralitos &lt;- filter(novillos, Procedencia == 'Los Corralitos')\n\nLa selección se puede hacer por más de una condición. Por ejemplo, seleccionar los de Los Corralitos que pesen más de 300 kg:\n\nfilter(novillos, Procedencia == 'Los Corralitos', Peso &gt; 300)\n\n# A tibble: 29 × 13\n   IDV   Tropa Procedencia Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 PO15…     2 Los Corral… 42938                  214           287           14\n 2 PO15…     2 Los Corral… 42939                  184           315           37\n 3 PO15…     2 Los Corral… 42937                  168           266           22\n 4 PO15…     2 Los Corral… 42937                  182           281           31\n 5 PO15…     2 Los Corral… 42938                  200           276           20\n 6 PO15…     2 Los Corral… 42937                  162           231           19\n 7 PO15…     2 Los Corral… 42937                  166           240           26\n 8 PO15…     2 Los Corral… 42942                  162           232           28\n 9 PO15…     1 Los Corral… 23/7/2017              252           343           31\n10 PO15…     1 Los Corral… 22/7/2017              234           338           23\n# ℹ 19 more rows\n# ℹ 6 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;\n\n\nfilter() asume que cada condicion se debe cumplir en simultaneo para que la observación sea seleccionada. Esto equivale a utilizar el operador &( Y ). En caso de querer seleccionar aquellos registros que cumple una u otra condicion se usa el operador | ( O ). Poniendo ! delante de la condicion se invierte la selección.\nPor ejemplo, para obtener novillos que son de Los Corralitos O pesan más de 300 kg.\n\nfilter(novillos, Procedencia == 'Los Corralitos' | Peso &gt; 300)\n\n# A tibble: 841 × 13\n   IDV   Tropa Procedencia Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 GH73…     2 &lt;NA&gt;        42939                  188           306           51\n 2 IA67…     2 La Rosita   42940                  232           290            2\n 3 PO15…     2 La Alameda  42939                  204           290           33\n 4 GH73…     2 &lt;NA&gt;        42940                  204           303           27\n 5 SZ20…     2 La Alameda  42940                  202           300           30\n 6 IA67…     2 La Rosita   42940                  234           333           38\n 7 PO15…     2 Los Corral… 42938                  214           287           14\n 8 PO15…     2 Los Corral… 42939                  184           315           37\n 9 NS50…     2 La Rosita   42938                  234           288            0\n10 QX67…     2 La Alameda  42940                  206           262            2\n# ℹ 831 more rows\n# ℹ 6 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nSeleccionar los novillos que provienen de las siguientes procedencias: La Alameda y La Rosita.\nSeleccionar los novillos que a su vez pesan entre 250 y 350 kg.\nSeleccionar los novillos que NO provienen de La Alameda o La Rosita y a su vez pesan entrte 250 y 350 kg.\nGuardar los datos del punto anterior en un objeto nuevo.\n\n\n\n\n7.5.1 Filtrando valores faltantes\nEn algunas ocasiones los datos vienen incompletos y es necesario eliminar registros con algun dato faltante.\nA continuación un filtro que permite seleccionar los registros con al menos 1 valor NA\n\nnovillos |&gt; filter(if_any(everything(), is.na))\n\n# A tibble: 305 × 13\n   IDV   Tropa Procedencia Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 GH73…     2 &lt;NA&gt;        42939                  188           306           51\n 2 GH73…     2 &lt;NA&gt;        42940                  204           303           27\n 3 FC11…     2 &lt;NA&gt;        42937                  170           265           31\n 4 CW82…     2 &lt;NA&gt;        42937                  166           295           49\n 5 GE32…     2 &lt;NA&gt;        42937                  194           286           22\n 6 GH73…     2 &lt;NA&gt;        42942                  156           288           37\n 7 &lt;NA&gt;      2 &lt;NA&gt;        &lt;NA&gt;                   227           252           25\n 8 BX18…     2 &lt;NA&gt;        42983                  167           246           20\n 9 BX18…     2 &lt;NA&gt;        42983                  179           258           23\n10 FM58…     2 &lt;NA&gt;        42940                  176           284           46\n# ℹ 295 more rows\n# ℹ 6 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;\n\n\nPopdemos ver que hay 305 datos incompletos. Si quisieramos quedarons con los datos completos podemos usar drop_na()\n\nnovillos &lt;- novillos |&gt; drop_na()\nnovillos |&gt; filter(if_any(everything(), is.na))\n\n# A tibble: 0 × 13\n# ℹ 13 variables: IDV &lt;chr&gt;, Tropa &lt;dbl&gt;, Procedencia &lt;chr&gt;,\n#   Fecha_Ingreso &lt;chr&gt;, Peso_inicial &lt;dbl&gt;, Peso_anterior &lt;dbl&gt;,\n#   GPV_anterior &lt;dbl&gt;, GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;,\n#   Peso &lt;dbl&gt;, Días &lt;dbl&gt;, Días_total &lt;dbl&gt;"
  },
  {
    "objectID": "06_wrangling.html#encadenando-operaciones-operador-o",
    "href": "06_wrangling.html#encadenando-operaciones-operador-o",
    "title": "7  Manipulando datos",
    "section": "7.6 Encadenando operaciones (operador %>% o |>)",
    "text": "7.6 Encadenando operaciones (operador %&gt;% o |&gt;)\nEl operador %&gt;% (R &lt; 4.1) o |&gt; (R &gt;= 4.1.+) permite encadenar operaciones sucesivas para evitar tener que crear tablas intermedias o anidar funciones. El operador y se le de izquierda a derecha y se puede traducir como luego.\nPor ejemplo, reportar los IDV y Peso de los novillos con más de 250 kg. Esto implicaría seleccionar las columnas de interés creando tablas intermedias y luego filtrar la tabla o vice versa.\nCreando tablas intermedias\n\nnovillos2 &lt;- select(novillos, IDV, Peso)\nnovillos2\n\n# A tibble: 1,537 × 2\n   IDV        Peso\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 IA671B298   387\n 2 PO150A818   386\n 3 SZ208H766   382\n 4 IA671B133   374\n 5 PO150A532   371\n 6 PO150A563   369\n 7 NS509H071   365\n 8 QX678K546   365\n 9 QX675I247   362\n10 NS579B014   362\n# ℹ 1,527 more rows\n\nnovillos2 &lt;- filter(novillos2, Peso &gt; 250)\nnovillos2\n\n# A tibble: 1,440 × 2\n   IDV        Peso\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 IA671B298   387\n 2 PO150A818   386\n 3 SZ208H766   382\n 4 IA671B133   374\n 5 PO150A532   371\n 6 PO150A563   369\n 7 NS509H071   365\n 8 QX678K546   365\n 9 QX675I247   362\n10 NS579B014   362\n# ℹ 1,430 more rows\n\n\nAnidando las funciones:\n\nfilter(select(novillos, IDV, Peso), Peso &gt; 250)\n\n# A tibble: 1,440 × 2\n   IDV        Peso\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 IA671B298   387\n 2 PO150A818   386\n 3 SZ208H766   382\n 4 IA671B133   374\n 5 PO150A532   371\n 6 PO150A563   369\n 7 NS509H071   365\n 8 QX678K546   365\n 9 QX675I247   362\n10 NS579B014   362\n# ℹ 1,430 more rows\n\n\nUna opción más clara para leer y eficiente es usando |&gt;\n\nnovillos |&gt;\n  select(IDV, Peso) |&gt;\n  filter(Peso &gt;  250)\n\n# A tibble: 1,440 × 2\n   IDV        Peso\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 IA671B298   387\n 2 PO150A818   386\n 3 SZ208H766   382\n 4 IA671B133   374\n 5 PO150A532   371\n 6 PO150A563   369\n 7 NS509H071   365\n 8 QX678K546   365\n 9 QX675I247   362\n10 NS579B014   362\n# ℹ 1,430 more rows\n\n\nCon |&gt; se puede omitir el nombre de la tabla sobre la que se está trabajando (bonus: menos tipeo).\nLa última opción se lee: _tomar la tabla novillos, luego seleccionar las columnas IDV y Peso, luego filtrar los novillos con pesos mayores a 250 kg.\n\n\n\n\n\n\nACTIVIDAD\n\n\n\nEncadenar con el operador el filtro del punto 3 de la actividad anterior, selección de las variables Procedencia, IDV, Peso y la función View() para ver los datos resultantes."
  },
  {
    "objectID": "06_wrangling.html#ordenar-las-filas",
    "href": "06_wrangling.html#ordenar-las-filas",
    "title": "7  Manipulando datos",
    "section": "7.7 Ordenar las filas",
    "text": "7.7 Ordenar las filas\nPara ordenar según algún criterio aplicado a las columnas se usa arrange(). Por ejemplo, continuar con lo anterior pero mostrar ordenadospor peso.\n\nnovillos |&gt;\n  select(IDV, Peso) |&gt;\n  filter(Peso &gt;  250) |&gt;\n  arrange(Peso)\n\n# A tibble: 1,440 × 2\n   IDV        Peso\n   &lt;chr&gt;     &lt;dbl&gt;\n 1 SZ208H833   251\n 2 NS545A388   251\n 3 ME367A545   251\n 4 NS509H010   251\n 5 PO150A777   251\n 6 PO150A752   251\n 7 SZ208H765   252\n 8 NS545A455   252\n 9 SZ208I511   252\n10 ME367A548   252\n# ℹ 1,430 more rows\n\n\nCon desc(variable) se ordena de mayor a menor\n\nnovillos |&gt;\n  select(Procedencia, IDV, Peso) |&gt;\n  filter(Peso &gt;  250) |&gt;\n  arrange(desc(Peso))\n\n# A tibble: 1,440 × 3\n   Procedencia    IDV        Peso\n   &lt;chr&gt;          &lt;chr&gt;     &lt;dbl&gt;\n 1 La Rosita      IA671B276   397\n 2 La Rosita      IA671B298   387\n 3 La Alameda     PO150A818   386\n 4 La Alameda     SZ208H766   382\n 5 La Rosita      IA671B133   374\n 6 Los Corralitos PO150A532   371\n 7 La Alameda     PO150A866   371\n 8 Los Corralitos PO150A563   369\n 9 La Rosita      IA671B188   369\n10 Los Corralitos PO150A546   369\n# ℹ 1,430 more rows\n\n\nSi queremos ordenar por mas de una variable, tenemos que pasara los nombres de las mismas a arrange() en orden que queremos que se apliquen los criterios. Por ejemplo, ordenando por Procedencia, Peso y Peso_incial\n\nnovillos |&gt;\n  arrange(Procedencia, desc(Peso), desc(Peso_inicial))\n\n# A tibble: 1,537 × 13\n   IDV   Tropa Procedencia Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 PO15…     2 La Alameda  42939                  204           290           33\n 2 SZ20…     2 La Alameda  42940                  202           300           30\n 3 PO15…     1 La Alameda  23/7/2017              250           341           34\n 4 PO15…     1 La Alameda  23/7/2017              238           332           34\n 5 QX67…     2 La Alameda  42940                  206           262            2\n 6 PO15…     1 La Alameda  22/7/2017              242           331            5\n 7 QX67…     2 La Alameda  42940                  216           308           10\n 8 SZ20…     2 La Alameda  42940                  176           289           36\n 9 QX67…     2 La Alameda  42939                  164           285           36\n10 SZ20…     1 La Alameda  24/7/2017              212           354           45\n# ℹ 1,527 more rows\n# ℹ 6 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\nOrdenar los novillos por Procedencia y IDV."
  },
  {
    "objectID": "06_wrangling.html#crear-o-transformar-columnas",
    "href": "06_wrangling.html#crear-o-transformar-columnas",
    "title": "7  Manipulando datos",
    "section": "7.8 Crear o transformar columnas",
    "text": "7.8 Crear o transformar columnas\nPara crear nuevas columnas aplicando funciones a otras, o bien para transformar columnas se usa mutate(). Se pueden modificar más de una columna a la vez. Por ejemplo, suponiendo que interesa obtener la diferencia de peso desde el inicio del ciclo:\ndif_peso = Peso - Peso_inicial\n\nnovillos |&gt; \n  mutate(dif_peso = Peso - Peso_inicial) |&gt;\n  select(Peso, Peso_inicial, dif_peso)  # para que se vea mejor el resultado \n\n# A tibble: 1,537 × 3\n    Peso Peso_inicial dif_peso\n   &lt;dbl&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n 1   387          232      155\n 2   386          204      182\n 3   382          202      180\n 4   374          234      140\n 5   371          214      157\n 6   369          184      185\n 7   365          234      131\n 8   365          206      159\n 9   362          216      146\n10   362          240      122\n# ℹ 1,527 more rows\n\n\nEsto no cambia el set de datos novillos ya que no se lo asignó a ningun objeto. Para sobreescribir o actualiza el set de datos novillos hay que asignarlo al mismo objeto.\n\nnovillos &lt;- novillos |&gt; \n  mutate(dif_peso = Peso - Peso_inicial)\n\nAclaración: Si se hubiese usado select() el set de datos novillos solamente contendría las columnas seleccionadas.\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCalcular la ganancia de peso desde la última pesada Peso_anterior a la pesada actual Peso.\nCalcular la ganancia media daria tomando la duración del tiempo entre las pesadas del punto 1. (Días)\n\n\n\n\n7.8.1 Modificar varias columnas a la vez\nSupongamos que queremos expresar las columnas que contienen información de pesos en Tn. Podríamos hacer:\n\nnovillos |&gt; \n  mutate(\n    Peso_inicial_tn = Peso_inicial / 1000,\n    Peso_anterior_tn = Peso_anterior / 1000,\n    Peso_tn = Peso / 1000,\n  ) |&gt; \n  select(starts_with(\"Peso\"))\n\n# A tibble: 1,537 × 6\n   Peso_inicial Peso_anterior  Peso Peso_inicial_tn Peso_anterior_tn Peso_tn\n          &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;            &lt;dbl&gt;   &lt;dbl&gt;\n 1          232           290   387           0.232            0.29    0.387\n 2          204           290   386           0.204            0.29    0.386\n 3          202           300   382           0.202            0.3     0.382\n 4          234           333   374           0.234            0.333   0.374\n 5          214           287   371           0.214            0.287   0.371\n 6          184           315   369           0.184            0.315   0.369\n 7          234           288   365           0.234            0.288   0.365\n 8          206           262   365           0.206            0.262   0.365\n 9          216           308   362           0.216            0.308   0.362\n10          240           298   362           0.24             0.298   0.362\n# ℹ 1,527 more rows\n\n\nEste código quedaría mejor si usamos across() para aplicar una funcion across (a través) de varias columnas:\n\nnovillos |&gt; \n  mutate(across(starts_with(\"Peso\"), ~ .x / 1000, .names = \"{col}_tn\")) |&gt; \n  select(starts_with(\"Peso\"))\n\n# A tibble: 1,537 × 6\n   Peso_inicial Peso_anterior  Peso Peso_inicial_tn Peso_anterior_tn Peso_tn\n          &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;           &lt;dbl&gt;            &lt;dbl&gt;   &lt;dbl&gt;\n 1          232           290   387           0.232            0.29    0.387\n 2          204           290   386           0.204            0.29    0.386\n 3          202           300   382           0.202            0.3     0.382\n 4          234           333   374           0.234            0.333   0.374\n 5          214           287   371           0.214            0.287   0.371\n 6          184           315   369           0.184            0.315   0.369\n 7          234           288   365           0.234            0.288   0.365\n 8          206           262   365           0.206            0.262   0.365\n 9          216           308   362           0.216            0.308   0.362\n10          240           298   362           0.24             0.298   0.362\n# ℹ 1,527 more rows\n\n\nEl argumento .names sirve para aplicar un patrón a los nombres de las variables resultantes. En este caso {col} indica usar el nomnbre de la columna y _tn agregar el sufijo.\n\n\n7.8.2 Modifica con condicionales\nA veces las modificaciones hay que realizarlas a algunas celdas en particular, no a toda la columna. En esos casos es conveniente la función condicional ifelse().\nifelse(condicion, resultado_si, resultado_no)\nLa función evalua la condición y, si el resultado es TRUE devuelve resultado_si, caso contrario, resultado_no. Por ejemplo, si tenemos un vector de 10 calificaciones entre 0-100 podemos clasificarlas en aprobado/no aprobado.\n\nnotas &lt;- data.frame(\n  alumno = 1:10, nota = c(45, 12, 95, 80, 60, 55, 57, 78, 80, 100)\n)\nnotas\n\n   alumno nota\n1       1   45\n2       2   12\n3       3   95\n4       4   80\n5       5   60\n6       6   55\n7       7   57\n8       8   78\n9       9   80\n10     10  100\n\n\n\nnotas &lt;- notas |&gt; \n  mutate(condicion = ifelse(x &gt;= 60, \"aprobado\", \"no aprobado\"))\n\nError in `mutate()`:\nℹ In argument: `condicion = ifelse(x &gt;= 60, \"aprobado\", \"no aprobado\")`.\nCaused by error:\n! object 'x' not found\n\nnotas\n\n   alumno nota\n1       1   45\n2       2   12\n3       3   95\n4       4   80\n5       5   60\n6       6   55\n7       7   57\n8       8   78\n9       9   80\n10     10  100\n\n\nPara evaluaciones más complejas es necesario anidar los condicionales. En estos casos case_when() es mas versátil. Supongamos que queremos aplicar la escala de calificaciones.\n\nnotas &lt;- notas |&gt; \n  mutate(\n    calificacion = case_when(\n      nota == 100 ~ \"Sobresaliente\",\n      nota &gt;= 90 & nota &lt; 100 ~ \"Distinguido\",\n      nota &gt;= 80 & nota &lt; 90 ~ \"Muy Bueno\",\n      nota &gt;= 70 & nota &lt; 80 ~ \"Bueno\",\n      nota &gt;= 60 & nota &lt; 70 ~ \"Aprobado\",\n      TRUE ~ \"Insuficiente\"\n    )\n  )\nnotas\n\n   alumno nota  calificacion\n1       1   45  Insuficiente\n2       2   12  Insuficiente\n3       3   95   Distinguido\n4       4   80     Muy Bueno\n5       5   60      Aprobado\n6       6   55  Insuficiente\n7       7   57  Insuficiente\n8       8   78         Bueno\n9       9   80     Muy Bueno\n10     10  100 Sobresaliente\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nClasificar los novillos segun el Peso en pesados/livianos si superan los 300 kg en una nueva variable grupo.\nActualizar la columna anterior pero dividiendo los novillos según Peso en tres grupos: pesados (&gt; 300 kg), intermedios (250-300 kg), y livianos (&lt; 250 kg).\nClasificar los novillos según peso inicial en alto/bajo aplicando un corte según la Procedencia. Los cortes son:\n\n\n\n\nProcedenciaPeso_inicialLa Alameda172La Rosita180Los Corralitos194"
  },
  {
    "objectID": "06_wrangling.html#resumir-datos",
    "href": "06_wrangling.html#resumir-datos",
    "title": "7  Manipulando datos",
    "section": "7.9 Resumir datos",
    "text": "7.9 Resumir datos\nMediante summarise() se pueden aplicar funciones para resumir en un solo valor los valores de las columnas. Las funciones a aplicar deben devolver un único valor, por ejemplo mean(). Si usamos summary() esto devolverá 6 valores y dará error.\n\nnovillos |&gt;\n  summarise(\n    media = mean(Peso), \n    sd = sd(Peso), \n    n = n(), \n    suma = sum(Peso), \n    procedencias = n_distinct(Procedencia)\n  )\n\n# A tibble: 1 × 5\n  media    sd     n   suma procedencias\n  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;        &lt;int&gt;\n1  296.  30.1  1537 455353            3\n\n\nNuevamente estos resultados pueden asignarse a otro objeto o bien encadenarse con otras operaciones.\nAl igual que con mutate() se puede aplicar across() y resumir varias columnas a la vez. Podemos pasarle una o varias funciones a la vez. En este último caso tiene que ser en una lista con el patrón nombre = funcion\nPor ejemplo: media = mean\n\nnovillos |&gt; \n  summarise(\n    across(\n      .cols = starts_with(\"Peso\"), \n      .fns = list(media = mean, sd = sd, n = length), \n      .names = \"{col}_{fn}\"\n    )\n  ) \n\n# A tibble: 1 × 9\n  Peso_inicial_media Peso_inicial_sd Peso_inicial_n Peso_anterior_media\n               &lt;dbl&gt;           &lt;dbl&gt;          &lt;int&gt;               &lt;dbl&gt;\n1               178.            32.5           1537                261.\n# ℹ 5 more variables: Peso_anterior_sd &lt;dbl&gt;, Peso_anterior_n &lt;int&gt;,\n#   Peso_media &lt;dbl&gt;, Peso_sd &lt;dbl&gt;, Peso_n &lt;int&gt;\n\n\nEl argumento .names sirve para aplicar un patrón a los nombres de las variables resultantes.\nCuando se exploran/analizan datos categóricos, es común averiguar cuales son la cantidad de valores únicos en una columna o combinación de columnas. Esto se logra con distinct()\n\nnovillos |&gt; distinct(Procedencia, Tropa)\n\n# A tibble: 6 × 2\n  Procedencia    Tropa\n  &lt;chr&gt;          &lt;dbl&gt;\n1 La Rosita          2\n2 La Alameda         2\n3 Los Corralitos     2\n4 La Rosita          1\n5 La Alameda         1\n6 Los Corralitos     1\n\n\nTambién es frecuente realizar conteos. Esto se puede hacer con la función table() o xtabs() de R base. No obstante, dplyr ofrece la función count() que es muy versátil.\nPor ejemplo, si queremos contar la cantidad total de novillos\n\nnovillos |&gt; count()\n\n# A tibble: 1 × 1\n      n\n  &lt;int&gt;\n1  1537\n\n\nSi queremos ver cuantos novillos hay por Procedencia:\n\nnovillos |&gt; count(Procedencia)\n\n# A tibble: 3 × 2\n  Procedencia        n\n  &lt;chr&gt;          &lt;int&gt;\n1 La Alameda       635\n2 La Rosita        845\n3 Los Corralitos    57\n\n\nSi quisieramos agregar las frecuencias en terminos relativos:\n\nnovillos |&gt; count(Procedencia) |&gt; mutate(prop = prop.table(n))\n\n# A tibble: 3 × 3\n  Procedencia        n   prop\n  &lt;chr&gt;          &lt;int&gt;  &lt;dbl&gt;\n1 La Alameda       635 0.413 \n2 La Rosita        845 0.550 \n3 Los Corralitos    57 0.0371\n\n\nTambien podemos contar la cantidad de registros que cumplen alguna condicion:\n\nnovillos |&gt; count(Peso &gt; 250) |&gt; mutate(prop = prop.table(n))\n\n# A tibble: 2 × 3\n  `Peso &gt; 250`     n   prop\n  &lt;lgl&gt;        &lt;int&gt;  &lt;dbl&gt;\n1 FALSE           97 0.0631\n2 TRUE          1440 0.937 \n\n\nEl 93.7% de los novillos tiene peso mayor a 250 kg.\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear una tabla de resumen con minimo (min()) y máximo (max()) de la variable Días\nCrear una tabla que tenga el conteo y frecuencias de novillos por Procedencias y Tropa que pesan más de 275 kg."
  },
  {
    "objectID": "06_wrangling.html#agrupar-último-pero-no-menos-importante",
    "href": "06_wrangling.html#agrupar-último-pero-no-menos-importante",
    "title": "7  Manipulando datos",
    "section": "7.10 Agrupar (último pero no menos importante!!)",
    "text": "7.10 Agrupar (último pero no menos importante!!)\nEl verbo group_by() es muy útil para aplicar operaciones en subgrupos y presentar todo junto ( split-apply-combine ). Lo que hace es indicar que en el data.frame hay una o más variables que conforman los grupos. Luego cada operación se aplica a esos subgrupos.\nEjemplo: calcular media, desvio, n y suma para cada procedencia, descartando los que tienen NA en Procedencia\n\nfns &lt;- list(media = mean, sd = sd, n = length)\nnovillos |&gt;\n  filter(!is.na(Procedencia)) |&gt; \n  group_by(Procedencia) |&gt;\n  summarise(across(Peso, fns))\n\n# A tibble: 3 × 4\n  Procedencia    Peso_media Peso_sd Peso_n\n  &lt;chr&gt;               &lt;dbl&gt;   &lt;dbl&gt;  &lt;int&gt;\n1 La Alameda           297.    28.3    635\n2 La Rosita            296.    31.2    845\n3 Los Corralitos       300.    33.3     57\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\nRepetir actividad anterior pero agrupando por Procedencia y Tropa agregando el valor mediano (median())"
  },
  {
    "objectID": "06_wrangling.html#tablas-pivot",
    "href": "06_wrangling.html#tablas-pivot",
    "title": "7  Manipulando datos",
    "section": "7.11 Tablas pivot",
    "text": "7.11 Tablas pivot\nAl igual que dplyr, las funciones de tidyr son compatibles con el operador |&gt;.\nLas funciones más importantes de este paquete son pivot_longer() y pivot_wider(), las cuales permiten de manera facil convertir tablas apaisadas en tablas longitudinales los nombres de algunas variables pasan a ser los valores de una nueva variable y los valores se combinan en una nueva variable.\nFormato wide\nx    y\n1    a\n2    b\n3    c\nFormato long\nname     value\nx        1\nx        2\nx        3\ny        a\ny        b\ny        c\nVeamos un ejemplo para crear una tabla apaisada. Las variables o columnas Peso, Peso_inicial y Peso_anterior pueden verse como la variable Peso medida en 3 momentos.\nPodríamos generar una tabla longitudinal combinando estas 3 variables (cols) en una sola (names_to = \"momento\") y creando otra que indique el momento de medición (values_to = \"peso\").\n\npesos_long &lt;- novillos |&gt; \n  pivot_longer(\n    cols = contains(\"Peso\"), \n    names_to = \"momento\", \n    values_to = \"peso\"\n  ) |&gt; \n  select(IDV, Procedencia, momento, peso)\npesos_long\n\n# A tibble: 6,148 × 4\n   IDV       Procedencia momento        peso\n   &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;         &lt;dbl&gt;\n 1 IA671B298 La Rosita   Peso_inicial    232\n 2 IA671B298 La Rosita   Peso_anterior   290\n 3 IA671B298 La Rosita   Peso            387\n 4 IA671B298 La Rosita   dif_peso        155\n 5 PO150A818 La Alameda  Peso_inicial    204\n 6 PO150A818 La Alameda  Peso_anterior   290\n 7 PO150A818 La Alameda  Peso            386\n 8 PO150A818 La Alameda  dif_peso        182\n 9 SZ208H766 La Alameda  Peso_inicial    202\n10 SZ208H766 La Alameda  Peso_anterior   300\n# ℹ 6,138 more rows\n\n\nComo vemos, ahora tenemos una tabla que para cada novillo IDV, tiene los pesos en los distintos momentos no como columnas sino como valores de la variable peso y la columna momento identifica el asocia el momento en que se pesó el animal.\nEl paso inverso sería usar pivot_wider():\n\npesos_long |&gt; \n  pivot_wider(\n    id_cols = IDV,\n    names_from = \"momento\",\n    values_from = \"peso\"\n  )\n\n# A tibble: 1,537 × 5\n   IDV       Peso_inicial Peso_anterior  Peso dif_peso\n   &lt;chr&gt;            &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 IA671B298          232           290   387      155\n 2 PO150A818          204           290   386      182\n 3 SZ208H766          202           300   382      180\n 4 IA671B133          234           333   374      140\n 5 PO150A532          214           287   371      157\n 6 PO150A563          184           315   369      185\n 7 NS509H071          234           288   365      131\n 8 QX678K546          206           262   365      159\n 9 QX675I247          216           308   362      146\n10 NS579B014          240           298   362      122\n# ℹ 1,527 more rows\n\n\nEn este caso, id_cols esta indicando que queremos mantener como identificador de la observacion solamente la variable IDV. Si lo omitimos toma por defecto todas las variables que no se espefician en names_from o values_from.\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear una base de datos con las columnas IDV, Procedencia y Peso.\nComo harías para tener una tabla de doble entrada donde cada columna tenga el nombre de la procedencia y cada fila el IDV y los valores sean los pesos."
  },
  {
    "objectID": "06_wrangling.html#unir-y-separar-columnas",
    "href": "06_wrangling.html#unir-y-separar-columnas",
    "title": "7  Manipulando datos",
    "section": "7.12 Unir y separar columnas",
    "text": "7.12 Unir y separar columnas\nOtras funcioners o verbos importantes son unite() y separate().\nSupongamos que queremos crear una columna que refleje la combinación de procedencia y número de tropa.\n\nnovillos &lt;- unite(novillos, col = \"procedencia_tropa\", Procedencia, Tropa)\nnovillos\n\n# A tibble: 1,537 × 13\n   IDV   procedencia_tropa Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;chr&gt;             &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 IA67… La Rosita_2       42940                  232           290            2\n 2 PO15… La Alameda_2      42939                  204           290           33\n 3 SZ20… La Alameda_2      42940                  202           300           30\n 4 IA67… La Rosita_2       42940                  234           333           38\n 5 PO15… Los Corralitos_2  42938                  214           287           14\n 6 PO15… Los Corralitos_2  42939                  184           315           37\n 7 NS50… La Rosita_2       42938                  234           288            0\n 8 QX67… La Alameda_2      42940                  206           262            2\n 9 QX67… La Alameda_2      42940                  216           308           10\n10 NS57… La Rosita_2       42983                  240           298           22\n# ℹ 1,527 more rows\n# ℹ 7 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;, dif_peso &lt;dbl&gt;\n\n\nComo vemos ahora desaparecieron las columnas Procedencia y Tropa ya que se fusionaron en una sola. Los valores tambien. Por defecto el separador que se usa es _ perto se puede cambiar facilmente con el argumento sep. Si quiseramos conservar las columnas originales podemos incluir remove = F\nAhora bien, el paso inverso de este proceso se puede lograr con separate()\n\nnovillos &lt;- separate(novillos, procedencia_tropa, into = c(\"Procedencia\", \"Tropa\"), sep = \"_\")\nnovillos\n\n# A tibble: 1,537 × 14\n   IDV   Procedencia Tropa Fecha_Ingreso Peso_inicial Peso_anterior GPV_anterior\n   &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;\n 1 IA67… La Rosita   2     42940                  232           290            2\n 2 PO15… La Alameda  2     42939                  204           290           33\n 3 SZ20… La Alameda  2     42940                  202           300           30\n 4 IA67… La Rosita   2     42940                  234           333           38\n 5 PO15… Los Corral… 2     42938                  214           287           14\n 6 PO15… Los Corral… 2     42939                  184           315           37\n 7 NS50… La Rosita   2     42938                  234           288            0\n 8 QX67… La Alameda  2     42940                  206           262            2\n 9 QX67… La Alameda  2     42940                  216           308           10\n10 NS57… La Rosita   2     42983                  240           298           22\n# ℹ 1,527 more rows\n# ℹ 7 more variables: GDM_anterior &lt;dbl&gt;, Fecha &lt;chr&gt;, Hora &lt;chr&gt;, Peso &lt;dbl&gt;,\n#   Días &lt;dbl&gt;, Días_total &lt;dbl&gt;, dif_peso &lt;dbl&gt;\n\n\nCuando hacemos la separación es muy importante identificar algun patron en los datos que permita hacer el corte de los valores. Por ejemplo: La Rosita_2 se separó en La Rosita y 2 gracias a que los unia el _."
  },
  {
    "objectID": "06_wrangling.html#unir-tablas",
    "href": "06_wrangling.html#unir-tablas",
    "title": "7  Manipulando datos",
    "section": "7.13 Unir tablas",
    "text": "7.13 Unir tablas\n\n7.13.1 bind_rows()/bind_cols()\nSi tenemos dos tablas de datos con el mismo set de columnas o el mismo número de filas podemos unirlas usando las funciones bind_rows() y bind_cols() repectivamente. Estas funciones son implementaciones más modernas de las funciones que ofrece R base: rbind() y cbind().\nPor ejemplo: suponiendo que tenemos la base de datos particionada por procedencias.\n\nla_rosita &lt;- filter(novillos, Procedencia == \"La Rosita\")\nla_alameda &lt;- filter(novillos, Procedencia == \"La Alameda\")\n\nLa cantidad de filas de cada procedencia es:\n\nla_rosita |&gt; nrow()\n\n[1] 845\n\nla_alameda |&gt; nrow()\n\n[1] 635\n\n\nTotal registros: 845 + 635 = 1840\nLuego, combinando ambas bases de datos por filas:\n\nrosita_mas_alameda &lt;- bind_rows(la_rosita, la_alameda)\nrosita_mas_alameda |&gt; nrow()\n\n[1] 1480\n\n\nEste método funciona si las columnas no coinciden, no importa el orden.\n\nbind_rows(\n  la_rosita |&gt; select(IDV, Procedencia, Peso_inicial),\n  la_alameda |&gt; select(IDV, Procedencia, Peso),\n)\n\n# A tibble: 1,480 × 4\n   IDV       Procedencia Peso_inicial  Peso\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 IA671B298 La Rosita            232    NA\n 2 IA671B133 La Rosita            234    NA\n 3 NS509H071 La Rosita            234    NA\n 4 NS579B014 La Rosita            240    NA\n 5 NS509G969 La Rosita            216    NA\n 6 NS509H060 La Rosita            194    NA\n 7 IA671B299 La Rosita            214    NA\n 8 PO150A492 La Rosita            176    NA\n 9 PO150A522 La Rosita            172    NA\n10 IA671B209 La Rosita            200    NA\n# ℹ 1,470 more rows\n\n\nDonde las columnas no se encuentran devuelve NA.\nAhora supongamos que tenemos la base con todos los casos pero por un lado la pesada al inicio, y por otro la pesada al dia de la fecha.\n\npesada_inicial &lt;- novillos |&gt; \n  select(IDV, Procedencia, Peso_inicial)\npesada_inicial\n\n# A tibble: 1,537 × 3\n   IDV       Procedencia    Peso_inicial\n   &lt;chr&gt;     &lt;chr&gt;                 &lt;dbl&gt;\n 1 IA671B298 La Rosita               232\n 2 PO150A818 La Alameda              204\n 3 SZ208H766 La Alameda              202\n 4 IA671B133 La Rosita               234\n 5 PO150A532 Los Corralitos          214\n 6 PO150A563 Los Corralitos          184\n 7 NS509H071 La Rosita               234\n 8 QX678K546 La Alameda              206\n 9 QX675I247 La Alameda              216\n10 NS579B014 La Rosita               240\n# ℹ 1,527 more rows\n\n\n\npesada_final &lt;- novillos |&gt; \n  select(IDV, Procedencia, Peso)\npesada_final\n\n# A tibble: 1,537 × 3\n   IDV       Procedencia     Peso\n   &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;\n 1 IA671B298 La Rosita        387\n 2 PO150A818 La Alameda       386\n 3 SZ208H766 La Alameda       382\n 4 IA671B133 La Rosita        374\n 5 PO150A532 Los Corralitos   371\n 6 PO150A563 Los Corralitos   369\n 7 NS509H071 La Rosita        365\n 8 QX678K546 La Alameda       365\n 9 QX675I247 La Alameda       362\n10 NS579B014 La Rosita        362\n# ℹ 1,527 more rows\n\n\nAmbas basers de datos tienen la misma cantidad de filas: 1537. Como podríamos unirlas?\nUna forma podría ser pegando ambas tablas fila a fila con bind_cols()\n\npesadas &lt;- bind_cols(pesada_inicial, pesada_final)\n\nNew names:\n• `IDV` -&gt; `IDV...1`\n• `Procedencia` -&gt; `Procedencia...2`\n• `IDV` -&gt; `IDV...4`\n• `Procedencia` -&gt; `Procedencia...5`\n\npesadas\n\n# A tibble: 1,537 × 6\n   IDV...1   Procedencia...2 Peso_inicial IDV...4   Procedencia...5  Peso\n   &lt;chr&gt;     &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;\n 1 IA671B298 La Rosita                232 IA671B298 La Rosita         387\n 2 PO150A818 La Alameda               204 PO150A818 La Alameda        386\n 3 SZ208H766 La Alameda               202 SZ208H766 La Alameda        382\n 4 IA671B133 La Rosita                234 IA671B133 La Rosita         374\n 5 PO150A532 Los Corralitos           214 PO150A532 Los Corralitos    371\n 6 PO150A563 Los Corralitos           184 PO150A563 Los Corralitos    369\n 7 NS509H071 La Rosita                234 NS509H071 La Rosita         365\n 8 QX678K546 La Alameda               206 QX678K546 La Alameda        365\n 9 QX675I247 La Alameda               216 QX675I247 La Alameda        362\n10 NS579B014 La Rosita                240 NS579B014 La Rosita         362\n# ℹ 1,527 more rows\n\n\nQué paso? Como ambas tablas tenían columnas que se repetian (IDV, Procedencia), no quedó mas remedio que reparar los nombres y evitar duplicados.\nPor otro lado, salvo excepciones, este método es poco confiable porque corremos el riesgo de que se cambie el oprden de los registros. Ejemplo:\n\nbind_cols(\n  pesada_inicial |&gt; arrange(desc(IDV)),\n  pesada_final |&gt; arrange(IDV)\n)\n\nNew names:\n• `IDV` -&gt; `IDV...1`\n• `Procedencia` -&gt; `Procedencia...2`\n• `IDV` -&gt; `IDV...4`\n• `Procedencia` -&gt; `Procedencia...5`\n\n\n# A tibble: 1,537 × 6\n   IDV...1   Procedencia...2 Peso_inicial IDV...4   Procedencia...5  Peso\n   &lt;chr&gt;     &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;\n 1 VP759A023 La Alameda               172 GN685B267 La Rosita         308\n 2 VP759A017 La Alameda               162 GN685B268 La Rosita         318\n 3 TP744A073 La Alameda               170 GN685B270 La Rosita         289\n 4 TO184B934 La Alameda               170 GN685D263 La Rosita         326\n 5 TO134B949 La Alameda               166 GT010B692 La Rosita         271\n 6 TM946A755 La Alameda               192 GT542A519 La Rosita         295\n 7 TM60B247  La Alameda               174 GT542A520 La Rosita         314\n 8 TM603T832 La Alameda               188 GT542A525 La Rosita         320\n 9 TM603C884 La Alameda               140 GT542A528 La Rosita         288\n10 TM603C877 La Alameda               186 GT542A529 La Rosita         279\n# ℹ 1,527 more rows\n\n\nPor otro lado, si ambas tablas no tienen la misma cantidad de filas, esta función no funciona.\n\nbind_cols(\n  pesada_inicial |&gt; filter(Procedencia == \"La Rosita\"),\n  pesada_final\n)\n\nError in `bind_cols()`:\n! Can't recycle `..1` (size 845) to match `..2` (size 1537).\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear una base de datos para cada tropa.\nEn la tropa 1 seleccionar IDV, Procedencia y Peso.\nEn tropa 2 seleccionar IDV, Procedencia y Días\nRecrear una tabla que tenga IDV, Procedencia, Peso y Dias.\n\n\n\nA continuación veremos alguinas estrategias mas confiables para unir tablas con igual o distinto numero de filas.\n\n\n7.13.2 Funciones *_join()\nComo su nombre lo dice, son un conjunto de funciones para realizar uniones entre tablas de datos. Lo clave es tener algunas coluimnas que sirvan de identificardor o claves ( keys ) de los registros.\nLa siguiente figura resumen las opciones posibles usando la lógica de diagramas de Venn:\nç\nEn todos los casos necesitamos contar con dos tablas X e Y y una o más variables que sirvan de claves. Tomando el ejemplo ultimo, usaremos IDV y Procedencia como claves.\n\npesos_iniciales &lt;- novillos |&gt; \n  select(IDV, Procedencia, Peso_inicial) |&gt;\n  filter(Procedencia %in% c(\"La Rosita\", \"La Alameda\"))\n\npesos_finales &lt;- novillos |&gt; \n  select(IDV, Procedencia, Peso) |&gt;\n  filter(Procedencia %in% c(\"La Rosita\", \"Los Corralitos\"))\n\nAsí tenemos:\n\ninner_join que representa la intersección de dos conjuntos. El resultado serán los registros que estámn presentes en ambos conjuntos de datos a la vez.\n\n\ninner_join(\n  pesos_iniciales, pesos_finales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 845 × 4\n   IDV       Procedencia Peso_inicial  Peso\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 IA671B298 La Rosita            232   387\n 2 IA671B133 La Rosita            234   374\n 3 NS509H071 La Rosita            234   365\n 4 NS579B014 La Rosita            240   362\n 5 NS509G969 La Rosita            216   361\n 6 NS509H060 La Rosita            194   357\n 7 IA671B299 La Rosita            214   357\n 8 PO150A492 La Rosita            176   357\n 9 PO150A522 La Rosita            172   356\n10 IA671B209 La Rosita            200   354\n# ℹ 835 more rows\n\n\nEn este caso devuelve solo La Rosita\n\nfull_join representa la unión cuyo resultado son todos los registros.\n\n\nfull_join(\n  pesos_iniciales, pesos_finales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 1,537 × 4\n   IDV       Procedencia Peso_inicial  Peso\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 IA671B298 La Rosita            232   387\n 2 PO150A818 La Alameda           204    NA\n 3 SZ208H766 La Alameda           202    NA\n 4 IA671B133 La Rosita            234   374\n 5 NS509H071 La Rosita            234   365\n 6 QX678K546 La Alameda           206    NA\n 7 QX675I247 La Alameda           216    NA\n 8 NS579B014 La Rosita            240   362\n 9 QX675H920 La Alameda           164    NA\n10 NS509G969 La Rosita            216   361\n# ℹ 1,527 more rows\n\n\nAcá vemos que tenemos un conjunto completo con todas las procedencias y datos completos solo para La Rosita porque estaba presente en ambas tablas.\n\nleft_join()/right_join() son las mas comunes y permiten agregar aun set de datos existente los registros que coinciden en el otro set de datos. Dependiendo de la dirección será left si llevamos los datos de Y a la tabla X or right caso contrario.\n\n\nleft_join(\n  pesos_iniciales, pesos_finales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 1,480 × 4\n   IDV       Procedencia Peso_inicial  Peso\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 IA671B298 La Rosita            232   387\n 2 PO150A818 La Alameda           204    NA\n 3 SZ208H766 La Alameda           202    NA\n 4 IA671B133 La Rosita            234   374\n 5 NS509H071 La Rosita            234   365\n 6 QX678K546 La Alameda           206    NA\n 7 QX675I247 La Alameda           216    NA\n 8 NS579B014 La Rosita            240   362\n 9 QX675H920 La Alameda           164    NA\n10 NS509G969 La Rosita            216   361\n# ℹ 1,470 more rows\n\n\n\nright_join(\n  pesos_iniciales, pesos_finales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 902 × 4\n   IDV       Procedencia Peso_inicial  Peso\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;\n 1 IA671B298 La Rosita            232   387\n 2 IA671B133 La Rosita            234   374\n 3 NS509H071 La Rosita            234   365\n 4 NS579B014 La Rosita            240   362\n 5 NS509G969 La Rosita            216   361\n 6 NS509H060 La Rosita            194   357\n 7 IA671B299 La Rosita            214   357\n 8 PO150A492 La Rosita            176   357\n 9 PO150A522 La Rosita            172   356\n10 IA671B209 La Rosita            200   354\n# ℹ 892 more rows\n\n\n\nanti_join() seria obtener la diferencia entre ambos conjuntos. Dependiendo de quien es X o Y determinamos la diferencia.\n\n\nanti_join(\n  pesos_iniciales, pesos_finales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 635 × 3\n   IDV       Procedencia Peso_inicial\n   &lt;chr&gt;     &lt;chr&gt;              &lt;dbl&gt;\n 1 PO150A818 La Alameda           204\n 2 SZ208H766 La Alameda           202\n 3 QX678K546 La Alameda           206\n 4 QX675I247 La Alameda           216\n 5 QX675H920 La Alameda           164\n 6 SZ208H800 La Alameda           176\n 7 PO150A838 La Alameda           186\n 8 PO150A723 La Alameda           224\n 9 QI282A292 La Alameda           192\n10 TB744A077 La Alameda           190\n# ℹ 625 more rows\n\n\n\nanti_join(\n  pesos_finales, pesos_iniciales,\n  by = c(\"IDV\", \"Procedencia\")\n)\n\n# A tibble: 57 × 3\n   IDV       Procedencia     Peso\n   &lt;chr&gt;     &lt;chr&gt;          &lt;dbl&gt;\n 1 PO150A532 Los Corralitos   371\n 2 PO150A563 Los Corralitos   369\n 3 PO150A558 Los Corralitos   329\n 4 PO150A581 Los Corralitos   327\n 5 PO150A534 Los Corralitos   320\n 6 PO150A541 Los Corralitos   317\n 7 PO150A585 Los Corralitos   315\n 8 PO150A565 Los Corralitos   304\n 9 PO150A539 Los Corralitos   299\n10 PO150A545 Los Corralitos   292\n# ℹ 47 more rows\n\n\n\n\n\n\n\n\nACTIVIDAD\n\n\n\n\nCrear una base de datos que contenga el IDV, Peso y Días de los novillos de tropa 1.\nCrear otra base de datos que contenga el IDV, Procedencia y Días de ambas tropas de la procedencia La Rosita.\nCrear una tabla que contenga los registros de la tabla creada en 1 más los datos de procedencia.\nFiltrar aquellos cuya procedencia haya resultado en NA. (se puede usar drop_na())"
  },
  {
    "objectID": "06_wrangling.html#manejando-cadenas-de-texto-y-factores",
    "href": "06_wrangling.html#manejando-cadenas-de-texto-y-factores",
    "title": "7  Manipulando datos",
    "section": "7.14 Manejando cadenas de texto y factores",
    "text": "7.14 Manejando cadenas de texto y factores\nFinalmente una actividad muy común en la exploración y limpieza de datos es el manejo de cadenas de texto y factores.\nPara eso hay dos paquetes clave que son forcats para manejar fatores y stringr para manipular/limpiar cadenas de texto.\nEs frecuente encontrar que las columnas de texto tiene valores mal escritos lo que genera incovenintes.\nSupongamos que algunos registros tienen mal escrita la procedencia. Para simular esto vamos a usar una versión muy potente del clasico ifelse() que se llama case_when()\n\nnovillos &lt;- novillos |&gt; \n  mutate(\n    Procedencia = case_when(\n      IDV == 'IA671B298' ~ \"La  Rosita\",\n      IDV == 'PO150A818' ~ \"La Alamedas\",\n      IDV == 'SZ208H766' ~ \"La Alameda \",\n      IDV == 'IA671B133' ~ \"Rosita\",\n      IDV == 'PO150A563' ~ \"Los C0rralitos\",\n      TRUE ~ Procedencia # esto es para capturar los que no cumplen lo de arriba\n      )\n  )\n\nAhora podemos ver que pasa cuando hacemos un conteo:\n\nnovillos |&gt; count(Procedencia)\n\n# A tibble: 8 × 2\n  Procedencia          n\n  &lt;chr&gt;            &lt;int&gt;\n1 \"La  Rosita\"         1\n2 \"La Alameda\"       633\n3 \"La Alameda \"        1\n4 \"La Alamedas\"        1\n5 \"La Rosita\"        843\n6 \"Los C0rralitos\"     1\n7 \"Los Corralitos\"    56\n8 \"Rosita\"             1\n\n\nTenemos más procedencias porque R interpreta que si no tienen el mismo texto, son distintas.\nTambien para econtrar valores disintos es distinct() que devulve los elementos distintos de un vector. Combinado con arrange puede servir.\n\nnovillos |&gt;\n  distinct(Procedencia) |&gt;\n  arrange(Procedencia)\n\n# A tibble: 8 × 1\n  Procedencia     \n  &lt;chr&gt;           \n1 \"La  Rosita\"    \n2 \"La Alameda\"    \n3 \"La Alameda \"   \n4 \"La Alamedas\"   \n5 \"La Rosita\"     \n6 \"Los C0rralitos\"\n7 \"Los Corralitos\"\n8 \"Rosita\"        \n\n\nAhora bien: ¿cómo solucionarlo?\n\n7.14.1 Usando stringr\nEste paquete tiene una serie de funciones que empiezan con str_. Vamos a ver como solucionar este problema aplicando algunas funciones. El cheatsheet (machete) completo está acá\nLa función str_squish() es útil para remover espacios duplicados o finales o iniciales. Si solo queremos eliminar los iniciales finales tenemos str_trim()\n\nstr_squish(\"La  Rosita \")\n\n[1] \"La Rosita\"\n\n\nAhora bien, errores de tipeo, salvo que sean patrones generales, hay que modificarlos caso por caso. La sintaxis es:\nstr_replace(texto_a_limpiar, patrón, reemplazo)\n\nstr_replace(\"Alamedas\", \"Alamedas\", \"Alameda\")\n\n[1] \"Alameda\"\n\n\nOtro ejemplo\n\nstr_replace(\"C0rralitos\", \"0\", \"o\")\n\n[1] \"Corralitos\"\n\n\nFinalmente, poniendo todo junto\n\ntmp &lt;- novillos |&gt; \n  mutate(\n    Procedencia = Procedencia |&gt; \n      str_squish() |&gt; \n      str_replace(\"Alamedas\", \"Alameda\") |&gt; \n      str_replace(\"^Rosita\", \"La Rosita\") |&gt; \n      str_replace(\"0\", \"o\")\n  )\ntmp |&gt; count(Procedencia)\n\n# A tibble: 3 × 2\n  Procedencia        n\n  &lt;chr&gt;          &lt;int&gt;\n1 La Alameda       635\n2 La Rosita        845\n3 Los Corralitos    57\n\n\n\n\n7.14.2 Usando forcats\nDependiendo del caso, las columnas character podemos usarlas como factor. En este escenario, el paquete forcats ofrece funciones para manejar los factores y sus niveles mediante funciones que empiezan por fct_. Vamos a mostrar algunos ejemplos, la guia completa o cheatsheet está acá\nSuponiendo que tenemos este factor con estos niveles:\n\nprocedencia &lt;- factor(\n  x = c(\"Alameda\", \"La Alameda\", \"Alamedas\"), \n  levels = c(\"Alam\", \"Alameda\", \"La Alameda\", \"Las Alamedas\", \"Alamedas\")\n)\nprocedencia\n\n[1] Alameda    La Alameda Alamedas  \nLevels: Alam Alameda La Alameda Las Alamedas Alamedas\n\n\nSi queremos modificar niveles manualmente podemos usar fct_recode(). El patron es nuevo_nivel = viejo_nivel\n\nfct_recode(procedencia, \"Alameda\" = \"La Alameda\")\n\n[1] Alameda  Alameda  Alamedas\nLevels: Alam Alameda Las Alamedas Alamedas\n\n\nSi tenemos varios que corregir y pertenecen a un mismo grupo podemos usar fct_collapse()\n\nfct_collapse(procedencia, \"La Alameda\" = c(\"Alameda\", \"La Alameda\", \"Alamedas\"))\n\n[1] La Alameda La Alameda La Alameda\nLevels: Alam La Alameda Las Alamedas\n\n\nSi quiéramos eliminar uno o varios niveles no usados podemos usar fct_drop()\n\nfct_drop(procedencia)\n\n[1] Alameda    La Alameda Alamedas  \nLevels: Alameda La Alameda Alamedas\n\n\nTambien podemos cambiar el orden, por ejemplo pasando Alamedas al primer lugar.\n\nfct_relevel(procedencia, \"Alamedas\", after = 0L)\n\n[1] Alameda    La Alameda Alamedas  \nLevels: Alamedas Alam Alameda La Alameda Las Alamedas\n\n\nPara solucionar nuestro problema con fct_collapse podemos solucionar todo:\n\ntmp &lt;- novillos |&gt; \n  mutate(\n    Procedencia = Procedencia |&gt; \n      fct_collapse(\n        \"La Rosita\" = c(\"La  Rosita\", \"La Rosita\", \"Rosita\"),\n        \"La Alameda\" = c(\"La Alameda\", \"La Alameda \", \"La Alamedas\"),\n        \"Los Corralitos\" = c(\"Los Corralitos\", \"Los C0rralitos\")\n      )\n  )\ntmp |&gt; count(Procedencia)\n\n# A tibble: 3 × 2\n  Procedencia        n\n  &lt;fct&gt;          &lt;int&gt;\n1 La Rosita        845\n2 La Alameda       635\n3 Los Corralitos    57"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "R Core Team. 2023. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/."
  }
]